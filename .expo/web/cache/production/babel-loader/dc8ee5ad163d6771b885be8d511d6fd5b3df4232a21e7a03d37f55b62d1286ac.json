{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.useDetectorUpdater=useDetectorUpdater;var _react=require(\"react\");var _attachHandlers=require(\"./attachHandlers\");var _updateHandlers=require(\"./updateHandlers\");var _needsToReattach=require(\"./needsToReattach\");var _dropHandlers=require(\"./dropHandlers\");var _utils=require(\"./utils\");var _findNodeHandle=_interopRequireDefault(require(\"../../../findNodeHandle\"));function useDetectorUpdater(state,preparedGesture,gesturesToAttach,gestureConfig,webEventHandlersRef){var forceRender=(0,_utils.useForceRender)();var updateAttachedGestures=(0,_react.useCallback)(function(skipConfigUpdate){var viewTag=(0,_findNodeHandle.default)(state.viewRef);var didUnderlyingViewChange=viewTag!==state.previousViewTag;if(didUnderlyingViewChange||(0,_needsToReattach.needsToReattach)(preparedGesture,gesturesToAttach)){(0,_utils.validateDetectorChildren)(state.viewRef);(0,_dropHandlers.dropHandlers)(preparedGesture);(0,_attachHandlers.attachHandlers)({preparedGesture:preparedGesture,gestureConfig:gestureConfig,gesturesToAttach:gesturesToAttach,webEventHandlersRef:webEventHandlersRef,viewTag:viewTag});if(didUnderlyingViewChange){state.previousViewTag=viewTag;state.forceRebuildReanimatedEvent=true;forceRender();}}else if(!skipConfigUpdate){(0,_updateHandlers.updateHandlers)(preparedGesture,gestureConfig,gesturesToAttach);}},[forceRender,gestureConfig,gesturesToAttach,preparedGesture,state,webEventHandlersRef]);return updateAttachedGestures;}","map":{"version":3,"names":["_react","require","_attachHandlers","_updateHandlers","_needsToReattach","_dropHandlers","_utils","_findNodeHandle","_interopRequireDefault","useDetectorUpdater","state","preparedGesture","gesturesToAttach","gestureConfig","webEventHandlersRef","forceRender","useForceRender","updateAttachedGestures","useCallback","skipConfigUpdate","viewTag","findNodeHandle","viewRef","didUnderlyingViewChange","previousViewTag","needsToReattach","validateDetectorChildren","dropHandlers","attachHandlers","forceRebuildReanimatedEvent","updateHandlers"],"sources":["/Users/primopan/WebstormProjects/AsdLanguauge/AsdLanguage/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector/useDetectorUpdater.ts"],"sourcesContent":["import React, { useCallback } from 'react';\nimport { GestureType } from '../gesture';\nimport { ComposedGesture } from '../gestureComposition';\n\nimport {\n  AttachedGestureState,\n  GestureDetectorState,\n  WebEventHandler,\n} from './types';\nimport { attachHandlers } from './attachHandlers';\nimport { updateHandlers } from './updateHandlers';\nimport { needsToReattach } from './needsToReattach';\nimport { dropHandlers } from './dropHandlers';\nimport { useForceRender, validateDetectorChildren } from './utils';\nimport findNodeHandle from '../../../findNodeHandle';\n\n// Returns a function that's responsible for updating the attached gestures\n// If the view has changed, it will reattach the handlers to the new view\n// If the view remains the same, it will update the handlers with the new config\nexport function useDetectorUpdater(\n  state: GestureDetectorState,\n  preparedGesture: AttachedGestureState,\n  gesturesToAttach: GestureType[],\n  gestureConfig: ComposedGesture | GestureType,\n  webEventHandlersRef: React.RefObject<WebEventHandler>\n) {\n  const forceRender = useForceRender();\n  const updateAttachedGestures = useCallback(\n    // skipConfigUpdate is used to prevent unnecessary updates when only checking if the view has changed\n    (skipConfigUpdate?: boolean) => {\n      // If the underlying view has changed we need to reattach handlers to the new view\n      const viewTag = findNodeHandle(state.viewRef) as number;\n      const didUnderlyingViewChange = viewTag !== state.previousViewTag;\n\n      if (\n        didUnderlyingViewChange ||\n        needsToReattach(preparedGesture, gesturesToAttach)\n      ) {\n        validateDetectorChildren(state.viewRef);\n        dropHandlers(preparedGesture);\n        attachHandlers({\n          preparedGesture,\n          gestureConfig,\n          gesturesToAttach,\n          webEventHandlersRef,\n          viewTag,\n        });\n\n        if (didUnderlyingViewChange) {\n          state.previousViewTag = viewTag;\n          state.forceRebuildReanimatedEvent = true;\n          forceRender();\n        }\n      } else if (!skipConfigUpdate) {\n        updateHandlers(preparedGesture, gestureConfig, gesturesToAttach);\n      }\n    },\n    [\n      forceRender,\n      gestureConfig,\n      gesturesToAttach,\n      preparedGesture,\n      state,\n      webEventHandlersRef,\n    ]\n  );\n\n  return updateAttachedGestures;\n}\n"],"mappings":"0LAAA,IAAAA,MAAA,CAAAC,OAAA,UASA,IAAAC,eAAA,CAAAD,OAAA,qBACA,IAAAE,eAAA,CAAAF,OAAA,qBACA,IAAAG,gBAAA,CAAAH,OAAA,sBACA,IAAAI,aAAA,CAAAJ,OAAA,mBACA,IAAAK,MAAA,CAAAL,OAAA,YACA,IAAAM,eAAA,CAAAC,sBAAA,CAAAP,OAAA,6BAKO,QAAS,CAAAQ,kBAATA,CACLC,KADK,CAELC,eAFK,CAGLC,gBAHK,CAILC,aAJK,CAKLC,mBALK,CAML,CACA,GAAM,CAAAC,WAAW,CAAG,GAAAC,qBAAc,GAAlC,CACA,GAAM,CAAAC,sBAAsB,CAAG,GAAAC,kBAAW,EAEvC,SAAAC,gBAAD,CAAgC,CAE9B,GAAM,CAAAC,OAAO,CAAG,GAAAC,uBAAc,EAACX,KAAK,CAACY,OAAP,CAA9B,CACA,GAAM,CAAAC,uBAAuB,CAAGH,OAAO,GAAKV,KAAK,CAACc,eAAlD,CAEA,GACED,uBAAuB,EACvB,GAAAE,gCAAe,EAACd,eAAD,CAAkBC,gBAAlB,CAFjB,CAGE,CACA,GAAAc,+BAAwB,EAAChB,KAAK,CAACY,OAAP,CAAxB,CACA,GAAAK,0BAAY,EAAChB,eAAD,CAAZ,CACA,GAAAiB,8BAAc,EAAC,CACbjB,eADa,CACbA,eADa,CAEbE,aAFa,CAEbA,aAFa,CAGbD,gBAHa,CAGbA,gBAHa,CAIbE,mBAJa,CAIbA,mBAJa,CAKbM,OAAA,CAAAA,OALa,CAAD,CAAd,CAQA,GAAIG,uBAAJ,CAA6B,CAC3Bb,KAAK,CAACc,eAAN,CAAwBJ,OAAxB,CACAV,KAAK,CAACmB,2BAAN,CAAoC,IAApC,CACAd,WAAW,GACZ,CACF,CAnBD,IAmBO,IAAI,CAACI,gBAAL,CAAuB,CAC5B,GAAAW,8BAAc,EAACnB,eAAD,CAAkBE,aAAlB,CAAiCD,gBAAjC,CAAd,CACD,CACF,CA7BuC,CA8BxC,CACEG,WADF,CAEEF,aAFF,CAGED,gBAHF,CAIED,eAJF,CAKED,KALF,CAMEI,mBANF,CA9BwC,CAA1C,CAwCA,MAAO,CAAAG,sBAAP,CACD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}