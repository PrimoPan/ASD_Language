{"ast":null,"code":"\"use strict\";var _slicedToArray=require(\"@babel/runtime/helpers/slicedToArray\");var _defineProperty=require(\"@babel/runtime/helpers/defineProperty\");var _toConsumableArray=require(\"@babel/runtime/helpers/toConsumableArray\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.getStateFromPath=getStateFromPath;var _escapeStringRegexp=_interopRequireDefault(require(\"escape-string-regexp\"));var queryString=_interopRequireWildcard(require(\"query-string\"));var _arrayStartsWith=require(\"./arrayStartsWith.js\");var _findFocusedRoute=require(\"./findFocusedRoute.js\");var _getPatternParts=require(\"./getPatternParts.js\");var _isArrayEqual=require(\"./isArrayEqual.js\");var _validatePathConfig=require(\"./validatePathConfig.js\");function _getRequireWildcardCache(e){if(\"function\"!=typeof WeakMap)return null;var r=new WeakMap(),t=new WeakMap();return(_getRequireWildcardCache=function _getRequireWildcardCache(e){return e?t:r;})(e);}function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if(\"default\"!==u&&{}.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u];}return n.default=e,t&&t.set(e,n),n;}function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e};}function getStateFromPath(path,options){var _options$path;var _getConfigResources=getConfigResources(options),initialRoutes=_getConfigResources.initialRoutes,configs=_getConfigResources.configs;var screens=options==null?void 0:options.screens;var remaining=path.replace(/\\/+/g,'/').replace(/^\\//,'').replace(/\\?.*$/,'');remaining=remaining.endsWith('/')?remaining:`${remaining}/`;var prefix=options==null||(_options$path=options.path)==null?void 0:_options$path.replace(/^\\//,'');if(prefix){var normalizedPrefix=prefix.endsWith('/')?prefix:`${prefix}/`;if(!remaining.startsWith(normalizedPrefix)){return undefined;}remaining=remaining.replace(normalizedPrefix,'');}if(screens===undefined){var _routes=remaining.split('/').filter(Boolean).map(function(segment){var name=decodeURIComponent(segment);return{name:name};});if(_routes.length){return createNestedStateObject(path,_routes,initialRoutes);}return undefined;}if(remaining==='/'){var match=configs.find(function(config){return config.segments.join('/')==='';});if(match){return createNestedStateObject(path,match.routeNames.map(function(name){return{name:name};}),initialRoutes,configs);}return undefined;}var result;var current;var _matchAgainstConfigs=matchAgainstConfigs(remaining,configs),routes=_matchAgainstConfigs.routes,remainingPath=_matchAgainstConfigs.remainingPath;if(routes!==undefined){current=createNestedStateObject(path,routes,initialRoutes,configs);remaining=remainingPath;result=current;}if(current==null||result==null){return undefined;}return result;}var cachedConfigResources=new WeakMap();function getConfigResources(options){if(!options)return prepareConfigResources();var cached=cachedConfigResources.get(options);if(cached)return cached;var resources=prepareConfigResources(options);cachedConfigResources.set(options,resources);return resources;}function prepareConfigResources(options){if(options){(0,_validatePathConfig.validatePathConfig)(options);}var initialRoutes=getInitialRoutes(options);var configs=getSortedNormalizedConfigs(initialRoutes,options==null?void 0:options.screens);checkForDuplicatedConfigs(configs);var configWithRegexes=getConfigsWithRegexes(configs);return{initialRoutes:initialRoutes,configs:configs,configWithRegexes:configWithRegexes};}function getInitialRoutes(options){var initialRoutes=[];if(options!=null&&options.initialRouteName){initialRoutes.push({initialRouteName:options.initialRouteName,parentScreens:[]});}return initialRoutes;}function getSortedNormalizedConfigs(initialRoutes){var _ref;var screens=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return(_ref=[]).concat.apply(_ref,_toConsumableArray(Object.keys(screens).map(function(key){return _createNormalizedConfigs(key,screens,initialRoutes,[],[],[]);}))).sort(function(a,b){if((0,_isArrayEqual.isArrayEqual)(a.segments,b.segments)){return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));}if((0,_arrayStartsWith.arrayStartsWith)(a.segments,b.segments)){return-1;}if((0,_arrayStartsWith.arrayStartsWith)(b.segments,a.segments)){return 1;}for(var i=0;i<Math.max(a.segments.length,b.segments.length);i++){if(a.segments[i]==null){return 1;}if(b.segments[i]==null){return-1;}var aWildCard=a.segments[i]==='*';var bWildCard=b.segments[i]==='*';var aParam=a.segments[i].startsWith(':');var bParam=b.segments[i].startsWith(':');var aRegex=aParam&&a.segments[i].includes('(');var bRegex=bParam&&b.segments[i].includes('(');if(aWildCard&&bWildCard||aRegex&&bRegex){continue;}if(aWildCard&&!bWildCard){return 1;}if(bWildCard&&!aWildCard){return-1;}if(aParam&&!bParam){return 1;}if(bParam&&!aParam){return-1;}if(aRegex&&!bRegex){return-1;}if(bRegex&&!aRegex){return 1;}}return a.segments.length-b.segments.length;});}function checkForDuplicatedConfigs(configs){configs.reduce(function(acc,config){var pattern=config.segments.join('/');if(acc[pattern]){var a=acc[pattern].routeNames;var b=config.routeNames;var intersects=a.length>b.length?b.every(function(it,i){return a[i]===it;}):a.every(function(it,i){return b[i]===it;});if(!intersects){throw new Error(`Found conflicting screens with the same pattern. The pattern '${pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);}}return Object.assign(acc,_defineProperty({},pattern,config));},{});}function getConfigsWithRegexes(configs){return configs.map(function(c){return Object.assign({},c,{regex:c.regex?new RegExp(c.regex.source+'$'):undefined});});}var matchAgainstConfigs=function matchAgainstConfigs(remaining,configs){var routes;var remainingPath=remaining;var _loop=function _loop(config){if(!config.regex){return 0;}var match=remainingPath.match(config.regex);if(match){routes=config.routeNames.map(function(routeName){var routeConfig=configs.find(function(c){return c.screen===routeName&&(0,_arrayStartsWith.arrayStartsWith)(config.segments,c.segments);});var params=routeConfig&&match.groups?Object.fromEntries(Object.entries(match.groups).map(function(_ref2){var _ref3=_slicedToArray(_ref2,2),key=_ref3[0],value=_ref3[1];var index=Number(key.replace('param_',''));var param=routeConfig.params.find(function(it){return it.index===index;});if((param==null?void 0:param.screen)===routeName&&param!=null&&param.name){return[param.name,value];}return null;}).filter(function(it){return it!=null;}).map(function(_ref4){var _routeConfig$parse;var _ref5=_slicedToArray(_ref4,2),key=_ref5[0],value=_ref5[1];if(value==null){return[key,undefined];}var decoded=decodeURIComponent(value);var parsed=(_routeConfig$parse=routeConfig.parse)!=null&&_routeConfig$parse[key]?routeConfig.parse[key](decoded):decoded;return[key,parsed];})):undefined;if(params&&Object.keys(params).length){return{name:routeName,params:params};}return{name:routeName};});remainingPath=remainingPath.replace(match[0],'');return 1;}},_ret;for(var config of configs){_ret=_loop(config);if(_ret===0)continue;if(_ret===1)break;}return{routes:routes,remainingPath:remainingPath};};var _createNormalizedConfigs=function createNormalizedConfigs(screen,routeConfig,initials,paths,parentScreens,routeNames){var configs=[];routeNames.push(screen);parentScreens.push(screen);var config=routeConfig[screen];if(typeof config==='string'){paths.push({screen:screen,path:config});configs.push(createConfigItem(screen,_toConsumableArray(routeNames),_toConsumableArray(paths)));}else if(typeof config==='object'){var _config$alias;if(typeof config.path==='string'){if(config.exact&&config.path==null){throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. \\`path: ''\\`.`);}var aliasConfigs=[];if(config.alias){for(var alias of config.alias){if(typeof alias==='string'){aliasConfigs.push(createConfigItem(screen,_toConsumableArray(routeNames),[].concat(_toConsumableArray(paths),[{screen:screen,path:alias}]),config.parse));}else if(typeof alias==='object'){aliasConfigs.push(createConfigItem(screen,_toConsumableArray(routeNames),alias.exact?[{screen:screen,path:alias.path}]:[].concat(_toConsumableArray(paths),[{screen:screen,path:alias.path}]),alias.parse));}}}if(config.exact){paths.length=0;}paths.push({screen:screen,path:config.path});configs.push(createConfigItem(screen,_toConsumableArray(routeNames),_toConsumableArray(paths),config.parse));configs.push.apply(configs,aliasConfigs);}if(typeof config!=='string'&&typeof config.path!=='string'&&(_config$alias=config.alias)!=null&&_config$alias.length){throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified in order to use 'alias'.`);}if(config.screens){if(config.initialRouteName){initials.push({initialRouteName:config.initialRouteName,parentScreens:parentScreens});}Object.keys(config.screens).forEach(function(nestedConfig){var result=_createNormalizedConfigs(nestedConfig,config.screens,initials,_toConsumableArray(paths),_toConsumableArray(parentScreens),routeNames);configs.push.apply(configs,_toConsumableArray(result));});}}routeNames.pop();return configs;};var createConfigItem=function createConfigItem(screen,routeNames,paths,parse){var parts=[];var _loop2=function _loop2(_screen){parts.push.apply(parts,_toConsumableArray((0,_getPatternParts.getPatternParts)(path).map(function(part){return Object.assign({},part,{screen:_screen});})));};for(var _ref6 of paths){var _screen=_ref6.screen;var path=_ref6.path;_loop2(_screen);}var regex=parts.length?new RegExp(`^(${parts.map(function(it,i){if(it.param){var reg=it.regex||'[^/]+';return`(((?<param_${i}>${reg})\\\\/)${it.optional?'?':''})`;}return`${it.segment==='*'?'.*':(0,_escapeStringRegexp.default)(it.segment)}\\\\/`;}).join('')})$`):undefined;var segments=parts.map(function(it){return it.segment;});var params=parts.map(function(it,i){return it.param?{index:i,screen:it.screen,name:it.param}:null;}).filter(function(it){return it!=null;});return{screen:screen,regex:regex,segments:segments,params:params,routeNames:routeNames,parse:parse};};var findParseConfigForRoute=function findParseConfigForRoute(routeName,flatConfig){for(var config of flatConfig){if(routeName===config.routeNames[config.routeNames.length-1]){return config.parse;}}return undefined;};var findInitialRoute=function findInitialRoute(routeName,parentScreens,initialRoutes){for(var config of initialRoutes){if(parentScreens.length===config.parentScreens.length){var sameParents=true;for(var i=0;i<parentScreens.length;i++){if(parentScreens[i].localeCompare(config.parentScreens[i])!==0){sameParents=false;break;}}if(sameParents){return routeName!==config.initialRouteName?config.initialRouteName:undefined;}}}return undefined;};var createStateObject=function createStateObject(initialRoute,route,isEmpty){if(isEmpty){if(initialRoute){return{index:1,routes:[{name:initialRoute},route]};}else{return{routes:[route]};}}else{if(initialRoute){return{index:1,routes:[{name:initialRoute},Object.assign({},route,{state:{routes:[]}})]};}else{return{routes:[Object.assign({},route,{state:{routes:[]}})]};}}};var createNestedStateObject=function createNestedStateObject(path,routes,initialRoutes,flatConfig){var route=routes.shift();var parentScreens=[];var initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);parentScreens.push(route.name);var state=createStateObject(initialRoute,route,routes.length===0);if(routes.length>0){var nestedState=state;while(route=routes.shift()){initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);var nestedStateIndex=nestedState.index||nestedState.routes.length-1;nestedState.routes[nestedStateIndex].state=createStateObject(initialRoute,route,routes.length===0);if(routes.length>0){nestedState=nestedState.routes[nestedStateIndex].state;}parentScreens.push(route.name);}}route=(0,_findFocusedRoute.findFocusedRoute)(state);route.path=path.replace(/\\/$/,'');var params=parseQueryParams(path,flatConfig?findParseConfigForRoute(route.name,flatConfig):undefined);if(params){route.params=Object.assign({},route.params,params);}return state;};var parseQueryParams=function parseQueryParams(path,parseConfig){var query=path.split('?')[1];var params=queryString.parse(query);if(parseConfig){Object.keys(params).forEach(function(name){if(Object.hasOwnProperty.call(parseConfig,name)&&typeof params[name]==='string'){params[name]=parseConfig[name](params[name]);}});}return Object.keys(params).length?params:undefined;};","map":{"version":3,"names":["_escapeStringRegexp","_interopRequireDefault","require","queryString","_interopRequireWildcard","_arrayStartsWith","_findFocusedRoute","_getPatternParts","_isArrayEqual","_validatePathConfig","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","getStateFromPath","path","options","_options$path","_getConfigResources","getConfigResources","initialRoutes","configs","screens","remaining","replace","endsWith","prefix","normalizedPrefix","startsWith","undefined","routes","split","filter","Boolean","map","segment","name","decodeURIComponent","length","createNestedStateObject","match","find","config","segments","join","routeNames","result","current","_matchAgainstConfigs","matchAgainstConfigs","remainingPath","cachedConfigResources","prepareConfigResources","cached","resources","validatePathConfig","getInitialRoutes","getSortedNormalizedConfigs","checkForDuplicatedConfigs","configWithRegexes","getConfigsWithRegexes","initialRouteName","push","parentScreens","_ref","arguments","concat","apply","_toConsumableArray","keys","key","createNormalizedConfigs","sort","b","isArrayEqual","localeCompare","arrayStartsWith","Math","max","aWildCard","bWildCard","aParam","bParam","aRegex","includes","bRegex","reduce","acc","pattern","intersects","every","it","Error","assign","_defineProperty","c","regex","RegExp","source","_loop","routeName","routeConfig","screen","params","groups","fromEntries","entries","_ref2","_ref3","_slicedToArray","value","index","Number","param","_ref4","_routeConfig$parse","_ref5","decoded","parsed","parse","_ret","initials","paths","createConfigItem","_config$alias","exact","aliasConfigs","alias","forEach","nestedConfig","pop","parts","_loop2","_screen","getPatternParts","part","_ref6","reg","optional","findParseConfigForRoute","flatConfig","findInitialRoute","sameParents","createStateObject","initialRoute","route","isEmpty","state","shift","nestedState","nestedStateIndex","findFocusedRoute","parseQueryParams","parseConfig","query"],"sources":["/Users/primopan/WebstormProjects/AsdLanguauge/AsdLanguage/node_modules/@react-navigation/core/src/getStateFromPath.tsx"],"sourcesContent":["import type {\n  InitialState,\n  NavigationState,\n  ParamListBase,\n  PartialState,\n} from '@react-navigation/routers';\nimport escape from 'escape-string-regexp';\nimport * as queryString from 'query-string';\n\nimport { arrayStartsWith } from './arrayStartsWith';\nimport { findFocusedRoute } from './findFocusedRoute';\nimport { getPatternParts, type PatternPart } from './getPatternParts';\nimport { isArrayEqual } from './isArrayEqual';\nimport type { PathConfig, PathConfigMap } from './types';\nimport { validatePathConfig } from './validatePathConfig';\n\ntype Options<ParamList extends {}> = {\n  path?: string;\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype ParseConfig = Record<string, (value: string) => unknown>;\n\ntype RouteConfig = {\n  screen: string;\n  regex?: RegExp;\n  segments: string[];\n  params: { screen: string; name?: string; index: number }[];\n  routeNames: string[];\n  parse?: ParseConfig;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  parentScreens: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\ntype ParsedRoute = {\n  name: string;\n  path?: string;\n  params?: Record<string, unknown> | undefined;\n};\n\ntype ConfigResources = {\n  initialRoutes: InitialRouteConfig[];\n  configs: RouteConfig[];\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport function getStateFromPath<ParamList extends {}>(\n  path: string,\n  options?: Options<ParamList>\n): ResultState | undefined {\n  const { initialRoutes, configs } = getConfigResources(options);\n\n  const screens = options?.screens;\n\n  let remaining = path\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n\n  const prefix = options?.path?.replace(/^\\//, ''); // Remove extra leading slash\n\n  if (prefix) {\n    // Make sure there is a trailing slash\n    const normalizedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;\n\n    // If the path doesn't start with the prefix, it's not a match\n    if (!remaining.startsWith(normalizedPrefix)) {\n      return undefined;\n    }\n\n    // Remove the prefix from the path\n    remaining = remaining.replace(normalizedPrefix, '');\n  }\n\n  if (screens === undefined) {\n    // When no config is specified, use the path segments as route names\n    const routes = remaining\n      .split('/')\n      .filter(Boolean)\n      .map((segment) => {\n        const name = decodeURIComponent(segment);\n        return { name };\n      });\n\n    if (routes.length) {\n      return createNestedStateObject(path, routes, initialRoutes);\n    }\n\n    return undefined;\n  }\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find((config) => config.segments.join('/') === '');\n\n    if (match) {\n      return createNestedStateObject(\n        path,\n        match.routeNames.map((name) => ({ name })),\n        initialRoutes,\n        configs\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const { routes, remainingPath } = matchAgainstConfigs(remaining, configs);\n\n  if (routes !== undefined) {\n    // This will always be empty if full path matched\n    current = createNestedStateObject(path, routes, initialRoutes, configs);\n    remaining = remainingPath;\n    result = current;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  return result;\n}\n\n/**\n * Reference to the last used config resources. This is used to avoid recomputing the config resources when the options are the same.\n */\nconst cachedConfigResources = new WeakMap<Options<{}>, ConfigResources>();\n\nfunction getConfigResources<ParamList extends {}>(\n  options: Options<ParamList> | undefined\n) {\n  if (!options) return prepareConfigResources();\n\n  const cached = cachedConfigResources.get(options);\n\n  if (cached) return cached;\n\n  const resources = prepareConfigResources(options);\n\n  cachedConfigResources.set(options, resources);\n\n  return resources;\n}\n\nfunction prepareConfigResources(options?: Options<{}>) {\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const initialRoutes = getInitialRoutes(options);\n  const configs = getSortedNormalizedConfigs(initialRoutes, options?.screens);\n\n  checkForDuplicatedConfigs(configs);\n\n  const configWithRegexes = getConfigsWithRegexes(configs);\n\n  return {\n    initialRoutes,\n    configs,\n    configWithRegexes,\n  };\n}\n\nfunction getInitialRoutes(options?: Options<{}>) {\n  const initialRoutes: InitialRouteConfig[] = [];\n\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: [],\n    });\n  }\n\n  return initialRoutes;\n}\n\nfunction getSortedNormalizedConfigs(\n  initialRoutes: InitialRouteConfig[],\n  screens: Record<string, string | PathConfig<ParamListBase>> = {}\n) {\n  // Create a normalized configs array which will be easier to use\n  return ([] as RouteConfig[])\n    .concat(\n      ...Object.keys(screens).map((key) =>\n        createNormalizedConfigs(key, screens, initialRoutes, [], [], [])\n      )\n    )\n    .sort((a, b) => {\n      // Sort config from most specific to least specific:\n      // - more segments\n      // - static segments\n      // - params with regex\n      // - regular params\n      // - wildcard\n\n      // If 2 patterns are same, move the one with less route names up\n      // This is an error state, so it's only useful for consistent error messages\n      if (isArrayEqual(a.segments, b.segments)) {\n        return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n      }\n\n      // If one of the patterns starts with the other, it's more exhaustive\n      // So move it up\n      if (arrayStartsWith(a.segments, b.segments)) {\n        return -1;\n      }\n\n      if (arrayStartsWith(b.segments, a.segments)) {\n        return 1;\n      }\n\n      for (let i = 0; i < Math.max(a.segments.length, b.segments.length); i++) {\n        // if b is longer, b gets higher priority\n        if (a.segments[i] == null) {\n          return 1;\n        }\n\n        // if a is longer, a gets higher priority\n        if (b.segments[i] == null) {\n          return -1;\n        }\n\n        const aWildCard = a.segments[i] === '*';\n        const bWildCard = b.segments[i] === '*';\n        const aParam = a.segments[i].startsWith(':');\n        const bParam = b.segments[i].startsWith(':');\n        const aRegex = aParam && a.segments[i].includes('(');\n        const bRegex = bParam && b.segments[i].includes('(');\n\n        // if both are wildcard or regex, we compare next component\n        if ((aWildCard && bWildCard) || (aRegex && bRegex)) {\n          continue;\n        }\n\n        // if only a is wildcard, b gets higher priority\n        if (aWildCard && !bWildCard) {\n          return 1;\n        }\n\n        // if only b is wildcard, a gets higher priority\n        if (bWildCard && !aWildCard) {\n          return -1;\n        }\n\n        // If only a has a param, b gets higher priority\n        if (aParam && !bParam) {\n          return 1;\n        }\n\n        // If only b has a param, a gets higher priority\n        if (bParam && !aParam) {\n          return -1;\n        }\n\n        // if only a has regex, a gets higher priority\n        if (aRegex && !bRegex) {\n          return -1;\n        }\n\n        // if only b has regex, b gets higher priority\n        if (bRegex && !aRegex) {\n          return 1;\n        }\n      }\n\n      return a.segments.length - b.segments.length;\n    });\n}\n\nfunction checkForDuplicatedConfigs(configs: RouteConfig[]) {\n  // Check for duplicate patterns in the config\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\n    const pattern = config.segments.join('/');\n\n    if (acc[pattern]) {\n      const a = acc[pattern].routeNames;\n      const b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      const intersects =\n        a.length > b.length\n          ? b.every((it, i) => a[i] === it)\n          : a.every((it, i) => b[i] === it);\n\n      if (!intersects) {\n        throw new Error(\n          `Found conflicting screens with the same pattern. The pattern '${\n            pattern\n          }' resolves to both '${a.join(' > ')}' and '${b.join(\n            ' > '\n          )}'. Patterns must be unique and cannot resolve to more than one screen.`\n        );\n      }\n    }\n\n    return Object.assign(acc, {\n      [pattern]: config,\n    });\n  }, {});\n}\n\nfunction getConfigsWithRegexes(configs: RouteConfig[]) {\n  return configs.map((c) => ({\n    ...c,\n    // Add `$` to the regex to make sure it matches till end of the path and not just beginning\n    regex: c.regex ? new RegExp(c.regex.source + '$') : undefined,\n  }));\n}\n\nconst matchAgainstConfigs = (remaining: string, configs: RouteConfig[]) => {\n  let routes: ParsedRoute[] | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (match) {\n      routes = config.routeNames.map((routeName) => {\n        const routeConfig = configs.find((c) => {\n          // Check matching name AND pattern in case same screen is used at different levels in config\n          return (\n            c.screen === routeName &&\n            arrayStartsWith(config.segments, c.segments)\n          );\n        });\n\n        const params =\n          routeConfig && match.groups\n            ? Object.fromEntries(\n                Object.entries(match.groups)\n                  .map(([key, value]) => {\n                    const index = Number(key.replace('param_', ''));\n                    const param = routeConfig.params.find(\n                      (it) => it.index === index\n                    );\n\n                    if (param?.screen === routeName && param?.name) {\n                      return [param.name, value];\n                    }\n\n                    return null;\n                  })\n                  .filter((it) => it != null)\n                  .map(([key, value]) => {\n                    if (value == null) {\n                      return [key, undefined];\n                    }\n\n                    const decoded = decodeURIComponent(value);\n                    const parsed = routeConfig.parse?.[key]\n                      ? routeConfig.parse[key](decoded)\n                      : decoded;\n\n                    return [key, parsed];\n                  })\n              )\n            : undefined;\n\n        if (params && Object.keys(params).length) {\n          return { name: routeName, params };\n        }\n\n        return { name: routeName };\n      });\n\n      remainingPath = remainingPath.replace(match[0], '');\n\n      break;\n    }\n  }\n\n  return { routes, remainingPath };\n};\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: Record<string, string | PathConfig<ParamListBase>>,\n  initials: InitialRouteConfig[],\n  paths: { screen: string; path: string }[],\n  parentScreens: string[],\n  routeNames: string[]\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  parentScreens.push(screen);\n\n  const config = routeConfig[screen];\n\n  if (typeof config === 'string') {\n    paths.push({ screen, path: config });\n    configs.push(createConfigItem(screen, [...routeNames], [...paths]));\n  } else if (typeof config === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path == null) {\n        throw new Error(\n          `Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. \\`path: ''\\`.`\n        );\n      }\n\n      // We should add alias configs after the main config\n      // So unless they are more specific, main config will be matched first\n      const aliasConfigs = [];\n\n      if (config.alias) {\n        for (const alias of config.alias) {\n          if (typeof alias === 'string') {\n            aliasConfigs.push(\n              createConfigItem(\n                screen,\n                [...routeNames],\n                [...paths, { screen, path: alias }],\n                config.parse\n              )\n            );\n          } else if (typeof alias === 'object') {\n            aliasConfigs.push(\n              createConfigItem(\n                screen,\n                [...routeNames],\n                alias.exact\n                  ? [{ screen, path: alias.path }]\n                  : [...paths, { screen, path: alias.path }],\n                alias.parse\n              )\n            );\n          }\n        }\n      }\n\n      if (config.exact) {\n        // If it's an exact path, we don't need to keep track of the parent screens\n        // So we can clear it\n        paths.length = 0;\n      }\n\n      paths.push({ screen, path: config.path });\n      configs.push(\n        createConfigItem(screen, [...routeNames], [...paths], config.parse)\n      );\n\n      configs.push(...aliasConfigs);\n    }\n\n    if (\n      typeof config !== 'string' &&\n      typeof config.path !== 'string' &&\n      config.alias?.length\n    ) {\n      throw new Error(\n        `Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified in order to use 'alias'.`\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens,\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as Record<string, string | PathConfig<ParamListBase>>,\n          initials,\n          [...paths],\n          [...parentScreens],\n          routeNames\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  paths: { screen: string; path: string }[],\n  parse?: ParseConfig\n): RouteConfig => {\n  const parts: (PatternPart & { screen: string })[] = [];\n\n  // Parse the path string into parts for easier matching\n  for (const { screen, path } of paths) {\n    parts.push(...getPatternParts(path).map((part) => ({ ...part, screen })));\n  }\n\n  const regex = parts.length\n    ? new RegExp(\n        `^(${parts\n          .map((it, i) => {\n            if (it.param) {\n              const reg = it.regex || '[^/]+';\n\n              return `(((?<param_${i}>${reg})\\\\/)${it.optional ? '?' : ''})`;\n            }\n\n            return `${it.segment === '*' ? '.*' : escape(it.segment)}\\\\/`;\n          })\n          .join('')})$`\n      )\n    : undefined;\n\n  const segments = parts.map((it) => it.segment);\n  const params = parts\n    .map((it, i) =>\n      it.param\n        ? {\n            index: i,\n            screen: it.screen,\n            name: it.param,\n          }\n        : null\n    )\n    .filter((it) => it != null);\n\n  return {\n    screen,\n    regex,\n    segments,\n    params,\n    routeNames,\n    parse,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  parentScreens: string[],\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (parentScreens.length === config.parentScreens.length) {\n      let sameParents = true;\n      for (let i = 0; i < parentScreens.length; i++) {\n        if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {\n          sameParents = false;\n          break;\n        }\n      }\n      if (sameParents) {\n        return routeName !== config.initialRouteName\n          ? config.initialRouteName\n          : undefined;\n      }\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  route: ParsedRoute,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, route],\n      };\n    } else {\n      return {\n        routes: [route],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, { ...route, state: { routes: [] } }],\n      };\n    } else {\n      return {\n        routes: [{ ...route, state: { routes: [] } }],\n      };\n    }\n  }\n};\n\nconst createNestedStateObject = (\n  path: string,\n  routes: ParsedRoute[],\n  initialRoutes: InitialRouteConfig[],\n  flatConfig?: RouteConfig[]\n) => {\n  let route = routes.shift() as ParsedRoute;\n  const parentScreens: string[] = [];\n\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n  parentScreens.push(route.name);\n\n  const state: InitialState = createStateObject(\n    initialRoute,\n    route,\n    routes.length === 0\n  );\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as ParsedRoute)) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n      const nestedStateIndex =\n        nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex]\n          .state as InitialState;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state) as ParsedRoute;\n  route.path = path.replace(/\\/$/, '');\n\n  const params = parseQueryParams(\n    path,\n    flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined\n  );\n\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n\n  return state;\n};\n\nconst parseQueryParams = (\n  path: string,\n  parseConfig?: Record<string, (value: string) => unknown>\n) => {\n  const query = path.split('?')[1];\n  const params: Record<string, unknown> = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (\n        Object.hasOwnProperty.call(parseConfig, name) &&\n        typeof params[name] === 'string'\n      ) {\n        params[name] = parseConfig[name](params[name]);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}