{"ast":null,"code":"Object.defineProperty(exports,\"__esModule\",{value:true});exports.useAnimatedGesture=useAnimatedGesture;var _gesture=require(\"../gesture\");var _reanimatedWrapper=require(\"../reanimatedWrapper\");var _gestureStateManager=require(\"../gestureStateManager\");var _State=require(\"../../../State\");var _TouchEventType=require(\"../../../TouchEventType\");var _utils=require(\"../../../utils\");function getHandler(type,gesture){'worklet';switch(type){case _gesture.CALLBACK_TYPE.BEGAN:return gesture.onBegin;case _gesture.CALLBACK_TYPE.START:return gesture.onStart;case _gesture.CALLBACK_TYPE.UPDATE:return gesture.onUpdate;case _gesture.CALLBACK_TYPE.CHANGE:return gesture.onChange;case _gesture.CALLBACK_TYPE.END:return gesture.onEnd;case _gesture.CALLBACK_TYPE.FINALIZE:return gesture.onFinalize;case _gesture.CALLBACK_TYPE.TOUCHES_DOWN:return gesture.onTouchesDown;case _gesture.CALLBACK_TYPE.TOUCHES_MOVE:return gesture.onTouchesMove;case _gesture.CALLBACK_TYPE.TOUCHES_UP:return gesture.onTouchesUp;case _gesture.CALLBACK_TYPE.TOUCHES_CANCELLED:return gesture.onTouchesCancelled;}}function touchEventTypeToCallbackType(eventType){'worklet';switch(eventType){case _TouchEventType.TouchEventType.TOUCHES_DOWN:return _gesture.CALLBACK_TYPE.TOUCHES_DOWN;case _TouchEventType.TouchEventType.TOUCHES_MOVE:return _gesture.CALLBACK_TYPE.TOUCHES_MOVE;case _TouchEventType.TouchEventType.TOUCHES_UP:return _gesture.CALLBACK_TYPE.TOUCHES_UP;case _TouchEventType.TouchEventType.TOUCHES_CANCELLED:return _gesture.CALLBACK_TYPE.TOUCHES_CANCELLED;}return _gesture.CALLBACK_TYPE.UNDEFINED;}function runWorklet(type,gesture,event){'worklet';var handler=getHandler(type,gesture);if(gesture.isWorklet[type]){for(var _len=arguments.length,args=new Array(_len>3?_len-3:0),_key=3;_key<_len;_key++){args[_key-3]=arguments[_key];}handler===null||handler===void 0?void 0:handler.apply(void 0,[event].concat(args));}else if(handler){console.warn((0,_utils.tagMessage)('Animated gesture callback must be a worklet'));}}function isStateChangeEvent(event){'worklet';return event.oldState!=null;}function isTouchEvent(event){'worklet';return event.eventType!=null;}function useAnimatedGesture(preparedGesture,needsRebuild){if(!_reanimatedWrapper.Reanimated){return;}var sharedHandlersCallbacks=_reanimatedWrapper.Reanimated.useSharedValue(null);var lastUpdateEvent=_reanimatedWrapper.Reanimated.useSharedValue([]);var stateControllers=[];var callback=function callback(event){'worklet';var currentCallback=sharedHandlersCallbacks.value;if(!currentCallback){return;}for(var i=0;i<currentCallback.length;i++){var gesture=currentCallback[i];if(event.handlerTag!==gesture.handlerTag){continue;}if(isStateChangeEvent(event)){if(event.oldState===_State.State.UNDETERMINED&&event.state===_State.State.BEGAN){runWorklet(_gesture.CALLBACK_TYPE.BEGAN,gesture,event);}else if((event.oldState===_State.State.BEGAN||event.oldState===_State.State.UNDETERMINED)&&event.state===_State.State.ACTIVE){runWorklet(_gesture.CALLBACK_TYPE.START,gesture,event);lastUpdateEvent.value[gesture.handlerTag]=undefined;}else if(event.oldState!==event.state&&event.state===_State.State.END){if(event.oldState===_State.State.ACTIVE){runWorklet(_gesture.CALLBACK_TYPE.END,gesture,event,true);}runWorklet(_gesture.CALLBACK_TYPE.FINALIZE,gesture,event,true);}else if((event.state===_State.State.FAILED||event.state===_State.State.CANCELLED)&&event.state!==event.oldState){if(event.oldState===_State.State.ACTIVE){runWorklet(_gesture.CALLBACK_TYPE.END,gesture,event,false);}runWorklet(_gesture.CALLBACK_TYPE.FINALIZE,gesture,event,false);}}else if(isTouchEvent(event)){if(!stateControllers[i]){stateControllers[i]=_gestureStateManager.GestureStateManager.create(event.handlerTag);}if(event.eventType!==_TouchEventType.TouchEventType.UNDETERMINED){runWorklet(touchEventTypeToCallbackType(event.eventType),gesture,event,stateControllers[i]);}}else{runWorklet(_gesture.CALLBACK_TYPE.UPDATE,gesture,event);if(gesture.onChange&&gesture.changeEventCalculator){var _gesture$changeEventC;runWorklet(_gesture.CALLBACK_TYPE.CHANGE,gesture,(_gesture$changeEventC=gesture.changeEventCalculator)===null||_gesture$changeEventC===void 0?void 0:_gesture$changeEventC.call(gesture,event,lastUpdateEvent.value[gesture.handlerTag]));lastUpdateEvent.value[gesture.handlerTag]=event;}}}};var event=_reanimatedWrapper.Reanimated.useEvent(callback,['onGestureHandlerStateChange','onGestureHandlerEvent'],needsRebuild);preparedGesture.animatedEventHandler=event;preparedGesture.animatedHandlers=sharedHandlersCallbacks;}","map":{"version":3,"names":["_gesture","require","_reanimatedWrapper","_gestureStateManager","_State","_TouchEventType","_utils","getHandler","type","gesture","CALLBACK_TYPE","BEGAN","onBegin","START","onStart","UPDATE","onUpdate","CHANGE","onChange","END","onEnd","FINALIZE","onFinalize","TOUCHES_DOWN","onTouchesDown","TOUCHES_MOVE","onTouchesMove","TOUCHES_UP","onTouchesUp","TOUCHES_CANCELLED","onTouchesCancelled","touchEventTypeToCallbackType","eventType","TouchEventType","UNDEFINED","runWorklet","event","handler","isWorklet","_len","arguments","length","args","Array","_key","apply","concat","console","warn","tagMessage","isStateChangeEvent","oldState","isTouchEvent","useAnimatedGesture","preparedGesture","needsRebuild","Reanimated","sharedHandlersCallbacks","useSharedValue","lastUpdateEvent","stateControllers","callback","currentCallback","value","i","handlerTag","State","UNDETERMINED","state","ACTIVE","undefined","FAILED","CANCELLED","GestureStateManager","create","changeEventCalculator","_gesture$changeEventC","call","useEvent","animatedEventHandler","animatedHandlers"],"sources":["/Users/primopan/WebstormProjects/AsdLanguauge/AsdLanguage/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector/useAnimatedGesture.ts"],"sourcesContent":["import { HandlerCallbacks, CALLBACK_TYPE } from '../gesture';\nimport { Reanimated } from '../reanimatedWrapper';\nimport {\n  GestureTouchEvent,\n  GestureUpdateEvent,\n  GestureStateChangeEvent,\n} from '../../gestureHandlerCommon';\nimport {\n  GestureStateManager,\n  GestureStateManagerType,\n} from '../gestureStateManager';\nimport { State } from '../../../State';\nimport { TouchEventType } from '../../../TouchEventType';\nimport { tagMessage } from '../../../utils';\nimport { AttachedGestureState } from './types';\n\nfunction getHandler(\n  type: CALLBACK_TYPE,\n  gesture: HandlerCallbacks<Record<string, unknown>>\n) {\n  'worklet';\n  switch (type) {\n    case CALLBACK_TYPE.BEGAN:\n      return gesture.onBegin;\n    case CALLBACK_TYPE.START:\n      return gesture.onStart;\n    case CALLBACK_TYPE.UPDATE:\n      return gesture.onUpdate;\n    case CALLBACK_TYPE.CHANGE:\n      return gesture.onChange;\n    case CALLBACK_TYPE.END:\n      return gesture.onEnd;\n    case CALLBACK_TYPE.FINALIZE:\n      return gesture.onFinalize;\n    case CALLBACK_TYPE.TOUCHES_DOWN:\n      return gesture.onTouchesDown;\n    case CALLBACK_TYPE.TOUCHES_MOVE:\n      return gesture.onTouchesMove;\n    case CALLBACK_TYPE.TOUCHES_UP:\n      return gesture.onTouchesUp;\n    case CALLBACK_TYPE.TOUCHES_CANCELLED:\n      return gesture.onTouchesCancelled;\n  }\n}\n\nfunction touchEventTypeToCallbackType(\n  eventType: TouchEventType\n): CALLBACK_TYPE {\n  'worklet';\n  switch (eventType) {\n    case TouchEventType.TOUCHES_DOWN:\n      return CALLBACK_TYPE.TOUCHES_DOWN;\n    case TouchEventType.TOUCHES_MOVE:\n      return CALLBACK_TYPE.TOUCHES_MOVE;\n    case TouchEventType.TOUCHES_UP:\n      return CALLBACK_TYPE.TOUCHES_UP;\n    case TouchEventType.TOUCHES_CANCELLED:\n      return CALLBACK_TYPE.TOUCHES_CANCELLED;\n  }\n  return CALLBACK_TYPE.UNDEFINED;\n}\n\nfunction runWorklet(\n  type: CALLBACK_TYPE,\n  gesture: HandlerCallbacks<Record<string, unknown>>,\n  event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\n  ...args: unknown[]\n) {\n  'worklet';\n  const handler = getHandler(type, gesture);\n  if (gesture.isWorklet[type]) {\n    // @ts-ignore Logic below makes sure the correct event is send to the\n    // correct handler.\n    handler?.(event, ...args);\n  } else if (handler) {\n    console.warn(tagMessage('Animated gesture callback must be a worklet'));\n  }\n}\n\nfunction isStateChangeEvent(\n  event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n): event is GestureStateChangeEvent {\n  'worklet';\n  // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\n  return event.oldState != null;\n}\n\nfunction isTouchEvent(\n  event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n): event is GestureTouchEvent {\n  'worklet';\n  return event.eventType != null;\n}\n\nexport function useAnimatedGesture(\n  preparedGesture: AttachedGestureState,\n  needsRebuild: boolean\n) {\n  if (!Reanimated) {\n    return;\n  }\n\n  // Hooks are called conditionally, but the condition is whether the\n  // react-native-reanimated is installed, which shouldn't change while running\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  >(null);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const lastUpdateEvent = Reanimated.useSharedValue<\n    (GestureUpdateEvent | undefined)[]\n  >([]);\n\n  // not every gesture needs a state controller, init them lazily\n  const stateControllers: GestureStateManagerType[] = [];\n\n  const callback = (\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\n  ) => {\n    'worklet';\n\n    const currentCallback = sharedHandlersCallbacks.value;\n    if (!currentCallback) {\n      return;\n    }\n\n    for (let i = 0; i < currentCallback.length; i++) {\n      const gesture = currentCallback[i];\n\n      if (event.handlerTag !== gesture.handlerTag) {\n        continue;\n      }\n\n      if (isStateChangeEvent(event)) {\n        if (\n          event.oldState === State.UNDETERMINED &&\n          event.state === State.BEGAN\n        ) {\n          runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\n        } else if (\n          (event.oldState === State.BEGAN ||\n            event.oldState === State.UNDETERMINED) &&\n          event.state === State.ACTIVE\n        ) {\n          runWorklet(CALLBACK_TYPE.START, gesture, event);\n          lastUpdateEvent.value[gesture.handlerTag] = undefined;\n        } else if (\n          event.oldState !== event.state &&\n          event.state === State.END\n        ) {\n          if (event.oldState === State.ACTIVE) {\n            runWorklet(CALLBACK_TYPE.END, gesture, event, true);\n          }\n          runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\n        } else if (\n          (event.state === State.FAILED || event.state === State.CANCELLED) &&\n          event.state !== event.oldState\n        ) {\n          if (event.oldState === State.ACTIVE) {\n            runWorklet(CALLBACK_TYPE.END, gesture, event, false);\n          }\n          runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\n        }\n      } else if (isTouchEvent(event)) {\n        if (!stateControllers[i]) {\n          stateControllers[i] = GestureStateManager.create(event.handlerTag);\n        }\n\n        if (event.eventType !== TouchEventType.UNDETERMINED) {\n          runWorklet(\n            touchEventTypeToCallbackType(event.eventType),\n            gesture,\n            event,\n            stateControllers[i]\n          );\n        }\n      } else {\n        runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\n\n        if (gesture.onChange && gesture.changeEventCalculator) {\n          runWorklet(\n            CALLBACK_TYPE.CHANGE,\n            gesture,\n            gesture.changeEventCalculator?.(\n              event,\n              lastUpdateEvent.value[gesture.handlerTag]\n            )\n          );\n\n          lastUpdateEvent.value[gesture.handlerTag] = event;\n        }\n      }\n    }\n  };\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const event = Reanimated.useEvent(\n    callback,\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\n    needsRebuild\n  );\n\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}