{"ast":null,"code":"Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=findNodeHandle;var _utils=require(\"./web/utils\");function findNodeHandle(viewRef){if((viewRef===null||viewRef===void 0?void 0:viewRef.viewTag)!==undefined){return findNodeHandle(viewRef.viewTag);}if(viewRef instanceof Element){if(viewRef.style.display==='contents'){return findNodeHandle(viewRef.firstChild);}return viewRef;}if((0,_utils.isRNSVGElement)(viewRef)){return viewRef.elementRef.current;}var element=viewRef===null||viewRef===void 0?void 0:viewRef.current;while(element&&element.style.display==='contents'){element=element.firstChild;}return element;}","map":{"version":3,"names":["_utils","require","findNodeHandle","viewRef","viewTag","undefined","Element","style","display","firstChild","isRNSVGElement","elementRef","current","element"],"sources":["/Users/primopan/WebstormProjects/AsdLanguauge/AsdLanguage/node_modules/react-native-gesture-handler/lib/module/findNodeHandle.web.ts"],"sourcesContent":["import type { GestureHandlerRef, SVGRef } from './web/interfaces';\nimport { isRNSVGElement } from './web/utils';\n\nexport default function findNodeHandle(\n  viewRef: GestureHandlerRef | SVGRef | HTMLElement | SVGElement\n): HTMLElement | SVGElement | number {\n  // Old API assumes that child handler is HTMLElement.\n  // However, if we nest handlers, we will get ref to another handler.\n  // In that case, we want to recursively call findNodeHandle with new handler viewTag (which can also be ref to another handler).\n  if ((viewRef as GestureHandlerRef)?.viewTag !== undefined) {\n    return findNodeHandle((viewRef as GestureHandlerRef).viewTag);\n  }\n\n  if (viewRef instanceof Element) {\n    if (viewRef.style.display === 'contents') {\n      return findNodeHandle(viewRef.firstChild as HTMLElement);\n    }\n\n    return viewRef;\n  }\n\n  if (isRNSVGElement(viewRef)) {\n    return (viewRef as SVGRef).elementRef.current;\n  }\n\n  // In new API, we receive ref object which `current` field points to  wrapper `div` with `display: contents;`.\n  // We want to return the first descendant (in DFS order) that doesn't have this property.\n  let element = (viewRef as GestureHandlerRef)?.current;\n\n  while (element && element.style.display === 'contents') {\n    element = element.firstChild as HTMLElement;\n  }\n\n  return element;\n}\n"],"mappings":"wFACA,IAAAA,MAAA,CAAAC,OAAA,gBAEe,QAAS,CAAAC,cAATA,CACbC,OADa,CAEsB,CAInC,GAAI,CAACA,OAAD,SAACA,OAAD,iBAACA,OAAD,CAAgCC,OAAhC,IAA4CC,SAAhD,CAA2D,CACzD,MAAO,CAAAH,cAAc,CAAEC,OAAD,CAA+BC,OAAhC,CAArB,CACD,CAED,GAAID,OAAO,WAAY,CAAAG,OAAvB,CAAgC,CAC9B,GAAIH,OAAO,CAACI,KAAR,CAAcC,OAAd,GAA0B,UAA9B,CAA0C,CACxC,MAAO,CAAAN,cAAc,CAACC,OAAO,CAACM,UAAT,CAArB,CACD,CAED,MAAO,CAAAN,OAAP,CACD,CAED,GAAI,GAAAO,qBAAc,EAACP,OAAD,CAAlB,CAA6B,CAC3B,MAAQ,CAAAA,OAAD,CAAoBQ,UAApB,CAA+BC,OAAtC,CACD,CAID,GAAI,CAAAC,OAAO,CAAIV,OAAJ,SAAIA,OAAJ,iBAAIA,OAAD,CAAgCS,OAA9C,CAEA,MAAOC,OAAO,EAAIA,OAAO,CAACN,KAAR,CAAcC,OAAd,GAA0B,UAA5C,CAAwD,CACtDK,OAAO,CAAGA,OAAO,CAACJ,UAAlB,CACD,CAED,MAAO,CAAAI,OAAP,CACD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}