{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.updateHandlers=updateHandlers;var _handlersRegistry=require(\"../../handlersRegistry\");var _RNGestureHandlerModule=_interopRequireDefault(require(\"../../../RNGestureHandlerModule\"));var _utils=require(\"../../utils\");var _ghQueueMicrotask=require(\"../../../ghQueueMicrotask\");var _utils2=require(\"./utils\");function updateHandlers(preparedGesture,gestureConfig,newGestures){gestureConfig.prepare();for(var i=0;i<newGestures.length;i++){var handler=preparedGesture.attachedGestures[i];(0,_utils2.checkGestureCallbacksForWorklets)(handler);if(newGestures[i].handlerTag!==handler.handlerTag){newGestures[i].handlerTag=handler.handlerTag;newGestures[i].handlers.handlerTag=handler.handlerTag;}}(0,_ghQueueMicrotask.ghQueueMicrotask)(function(){if(!preparedGesture.isMounted){return;}var shouldUpdateSharedValueIfUsed=preparedGesture.attachedGestures.length!==newGestures.length;for(var _i=0;_i<newGestures.length;_i++){var _handler=preparedGesture.attachedGestures[_i];if(_handler.handlers.gestureId!==newGestures[_i].handlers.gestureId&&(newGestures[_i].shouldUseReanimated||_handler.shouldUseReanimated)){shouldUpdateSharedValueIfUsed=true;}_handler.config=newGestures[_i].config;_handler.handlers=newGestures[_i].handlers;_RNGestureHandlerModule.default.updateGestureHandler(_handler.handlerTag,(0,_utils.filterConfig)(_handler.config,_utils2.ALLOWED_PROPS,(0,_utils2.extractGestureRelations)(_handler)));(0,_handlersRegistry.registerHandler)(_handler.handlerTag,_handler,_handler.config.testId);}if(preparedGesture.animatedHandlers&&shouldUpdateSharedValueIfUsed){var newHandlersValue=preparedGesture.attachedGestures.filter(function(g){return g.shouldUseReanimated;}).map(function(g){return g.handlers;});preparedGesture.animatedHandlers.value=newHandlersValue;}(0,_utils.scheduleFlushOperations)();});}","map":{"version":3,"names":["_handlersRegistry","require","_RNGestureHandlerModule","_interopRequireDefault","_utils","_ghQueueMicrotask","_utils2","updateHandlers","preparedGesture","gestureConfig","newGestures","prepare","i","length","handler","attachedGestures","checkGestureCallbacksForWorklets","handlerTag","handlers","ghQueueMicrotask","isMounted","shouldUpdateSharedValueIfUsed","gestureId","shouldUseReanimated","config","RNGestureHandlerModule","updateGestureHandler","filterConfig","ALLOWED_PROPS","extractGestureRelations","registerHandler","testId","animatedHandlers","newHandlersValue","filter","g","map","value","scheduleFlushOperations"],"sources":["/Users/primopan/WebstormProjects/AsdLanguauge/AsdLanguage/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector/updateHandlers.ts"],"sourcesContent":["import { GestureType, HandlerCallbacks } from '../gesture';\nimport { registerHandler } from '../../handlersRegistry';\nimport RNGestureHandlerModule from '../../../RNGestureHandlerModule';\nimport { filterConfig, scheduleFlushOperations } from '../../utils';\nimport { ComposedGesture } from '../gestureComposition';\nimport { ghQueueMicrotask } from '../../../ghQueueMicrotask';\nimport { AttachedGestureState } from './types';\nimport {\n  extractGestureRelations,\n  checkGestureCallbacksForWorklets,\n  ALLOWED_PROPS,\n} from './utils';\n\nexport function updateHandlers(\n  preparedGesture: AttachedGestureState,\n  gestureConfig: ComposedGesture | GestureType,\n  newGestures: GestureType[]\n) {\n  gestureConfig.prepare();\n\n  for (let i = 0; i < newGestures.length; i++) {\n    const handler = preparedGesture.attachedGestures[i];\n    checkGestureCallbacksForWorklets(handler);\n\n    // Only update handlerTag when it's actually different, it may be the same\n    // if gesture config object is wrapped with useMemo\n    if (newGestures[i].handlerTag !== handler.handlerTag) {\n      newGestures[i].handlerTag = handler.handlerTag;\n      newGestures[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n\n  // Use queueMicrotask to extract handlerTags, because when it's ran, all refs should be updated\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\n  // in case of external relations)\n  ghQueueMicrotask(() => {\n    if (!preparedGesture.isMounted) {\n      return;\n    }\n\n    // If amount of gesture configs changes, we need to update the callbacks in shared value\n    let shouldUpdateSharedValueIfUsed =\n      preparedGesture.attachedGestures.length !== newGestures.length;\n\n    for (let i = 0; i < newGestures.length; i++) {\n      const handler = preparedGesture.attachedGestures[i];\n\n      // If the gestureId is different (gesture isn't wrapped with useMemo or its dependencies changed),\n      // we need to update the shared value, assuming the gesture runs on UI thread or the thread changed\n      if (\n        handler.handlers.gestureId !== newGestures[i].handlers.gestureId &&\n        (newGestures[i].shouldUseReanimated || handler.shouldUseReanimated)\n      ) {\n        shouldUpdateSharedValueIfUsed = true;\n      }\n\n      handler.config = newGestures[i].config;\n      handler.handlers = newGestures[i].handlers;\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(\n          handler.config,\n          ALLOWED_PROPS,\n          extractGestureRelations(handler)\n        )\n      );\n\n      registerHandler(handler.handlerTag, handler, handler.config.testId);\n    }\n\n    if (preparedGesture.animatedHandlers && shouldUpdateSharedValueIfUsed) {\n      const newHandlersValue = preparedGesture.attachedGestures\n        .filter((g) => g.shouldUseReanimated) // Ignore gestures that shouldn't run on UI\n        .map((g) => g.handlers) as unknown as HandlerCallbacks<\n        Record<string, unknown>\n      >[];\n\n      preparedGesture.animatedHandlers.value = newHandlersValue;\n    }\n\n    scheduleFlushOperations();\n  });\n}\n"],"mappings":"kLACA,IAAAA,iBAAA,CAAAC,OAAA,2BACA,IAAAC,uBAAA,CAAAC,sBAAA,CAAAF,OAAA,qCACA,IAAAG,MAAA,CAAAH,OAAA,gBAEA,IAAAI,iBAAA,CAAAJ,OAAA,8BAEA,IAAAK,OAAA,CAAAL,OAAA,YAMO,QAAS,CAAAM,cAATA,CACLC,eADK,CAELC,aAFK,CAGLC,WAHK,CAIL,CACAD,aAAa,CAACE,OAAd,GAEA,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGF,WAAW,CAACG,MAAhC,CAAwCD,CAAC,EAAzC,CAA6C,CAC3C,GAAM,CAAAE,OAAO,CAAGN,eAAe,CAACO,gBAAhB,CAAiCH,CAAjC,CAAhB,CACA,GAAAI,wCAAgC,EAACF,OAAD,CAAhC,CAIA,GAAIJ,WAAW,CAACE,CAAD,CAAX,CAAeK,UAAf,GAA8BH,OAAO,CAACG,UAA1C,CAAsD,CACpDP,WAAW,CAACE,CAAD,CAAX,CAAeK,UAAf,CAA4BH,OAAO,CAACG,UAApC,CACAP,WAAW,CAACE,CAAD,CAAX,CAAeM,QAAf,CAAwBD,UAAxB,CAAqCH,OAAO,CAACG,UAA7C,CACD,CACF,CAKD,GAAAE,kCAAgB,EAAC,UAAM,CACrB,GAAI,CAACX,eAAe,CAACY,SAArB,CAAgC,CAC9B,OACD,CAGD,GAAI,CAAAC,6BAA6B,CAC/Bb,eAAe,CAACO,gBAAhB,CAAiCF,MAAjC,GAA4CH,WAAW,CAACG,MAD1D,CAGA,IAAK,GAAI,CAAAD,EAAC,CAAG,CAAb,CAAgBA,EAAC,CAAGF,WAAW,CAACG,MAAhC,CAAwCD,EAAC,EAAzC,CAA6C,CAC3C,GAAM,CAAAE,QAAO,CAAGN,eAAe,CAACO,gBAAhB,CAAiCH,EAAjC,CAAhB,CAIA,GACEE,QAAO,CAACI,QAAR,CAAiBI,SAAjB,GAA+BZ,WAAW,CAACE,EAAD,CAAX,CAAeM,QAAf,CAAwBI,SAAvD,GACCZ,WAAW,CAACE,EAAD,CAAX,CAAeW,mBAAf,EAAsCT,QAAO,CAACS,mBAD/C,CADF,CAGE,CACAF,6BAA6B,CAAG,IAAhC,CACD,CAEDP,QAAO,CAACU,MAAR,CAAiBd,WAAW,CAACE,EAAD,CAAX,CAAeY,MAAhC,CACAV,QAAO,CAACI,QAAR,CAAmBR,WAAW,CAACE,EAAD,CAAX,CAAeM,QAAlC,CAEAO,+BAAsB,CAACC,oBAAvB,CACEZ,QAAO,CAACG,UADV,CAEE,GAAAU,mBAAY,EACVb,QAAO,CAACU,MADE,CAEVI,qBAFU,CAGV,GAAAC,+BAAuB,EAACf,QAAD,CAHb,CAFd,EASA,GAAAgB,iCAAe,EAAChB,QAAO,CAACG,UAAT,CAAqBH,QAArB,CAA8BA,QAAO,CAACU,MAAR,CAAeO,MAA7C,CAAf,CACD,CAED,GAAIvB,eAAe,CAACwB,gBAAhB,EAAoCX,6BAAxC,CAAuE,CACrE,GAAM,CAAAY,gBAAgB,CAAGzB,eAAe,CAACO,gBAAhB,CACtBmB,MADsB,CACd,SAAAC,CAAD,QAAO,CAAAA,CAAC,CAACZ,mBADM,IAEtBa,GAFsB,CAEjB,SAAAD,CAAD,QAAO,CAAAA,CAAC,CAACjB,QAFS,GAAzB,CAMAV,eAAe,CAACwB,gBAAhB,CAAiCK,KAAjC,CAAyCJ,gBAAzC,CACD,CAED,GAAAK,8BAAuB,IACxB,CA/Ce,CAAhB,CAgDD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}