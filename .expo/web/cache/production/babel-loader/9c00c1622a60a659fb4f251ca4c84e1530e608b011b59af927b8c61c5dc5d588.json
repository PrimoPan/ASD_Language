{"ast":null,"code":"\"use strict\";var _toConsumableArray=require(\"@babel/runtime/helpers/toConsumableArray\");var _objectWithoutProperties=require(\"@babel/runtime/helpers/objectWithoutProperties\");var _slicedToArray=require(\"@babel/runtime/helpers/slicedToArray\");var _excluded=[\"screen\",\"if\"],_excluded2=[\"screens\",\"groups\"],_excluded3=[\"if\"];Object.defineProperty(exports,\"__esModule\",{value:true});exports.createComponentForStaticNavigation=createComponentForStaticNavigation;exports.createPathConfigForStaticNavigation=createPathConfigForStaticNavigation;var _react=_interopRequireWildcard(require(\"react\"));var React=_react;var _reactIs=require(\"react-is\");var _useRoute=require(\"./useRoute.js\");var _jsxRuntime=require(\"react/jsx-runtime\");function _getRequireWildcardCache(e){if(\"function\"!=typeof WeakMap)return null;var r=new WeakMap(),t=new WeakMap();return(_getRequireWildcardCache=function _getRequireWildcardCache(e){return e?t:r;})(e);}function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if(\"default\"!==u&&{}.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u];}return n.default=e,t&&t.set(e,n),n;}var MemoizedScreen=React.memo(function(_ref){var component=_ref.component;var route=(0,_useRoute.useRoute)();var children=React.createElement(component,{route:route});return children;});MemoizedScreen.displayName='Memo(Screen)';var getItemsFromScreens=function getItemsFromScreens(Screen,screens){return Object.entries(screens).map(function(_ref2){var _ref3=_slicedToArray(_ref2,2),name=_ref3[0],item=_ref3[1];var component;var props={};var useIf;var isNavigator=false;if('screen'in item){var screen=item.screen,_if=item.if,rest=_objectWithoutProperties(item,_excluded);useIf=_if;props=rest;if((0,_reactIs.isValidElementType)(screen)){component=screen;}else if('config'in screen){isNavigator=true;component=createComponentForStaticNavigation(screen,`${name}Navigator`);}}else if((0,_reactIs.isValidElementType)(item)){component=item;}else if('config'in item){isNavigator=true;component=createComponentForStaticNavigation(item,`${name}Navigator`);}if(component==null){throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);}var element=isNavigator?(React.createElement(component,{})):(0,_jsxRuntime.jsx)(MemoizedScreen,{component:component});return function(){var shouldRender=useIf==null||useIf();if(!shouldRender){return null;}return(0,_jsxRuntime.jsx)(Screen,Object.assign({name:name},props,{children:function children(){return element;}}),name);};});};function createComponentForStaticNavigation(tree,displayName){var Navigator=tree.Navigator,Group=tree.Group,Screen=tree.Screen,config=tree.config;var screens=config.screens,groups=config.groups,rest=_objectWithoutProperties(config,_excluded2);if(screens==null&&groups==null){throw new Error(\"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\");}var items=[];for(var key in config){if(key==='screens'&&screens){items.push.apply(items,_toConsumableArray(getItemsFromScreens(Screen,screens)));}if(key==='groups'&&groups){items.push.apply(items,_toConsumableArray(Object.entries(groups).map(function(_ref4){var _ref5=_slicedToArray(_ref4,2),key=_ref5[0],_ref5$=_ref5[1],useIf=_ref5$.if,group=_objectWithoutProperties(_ref5$,_excluded3);var groupItems=getItemsFromScreens(Screen,group.screens);return function(){var children=groupItems.map(function(item){return item();});var shouldRender=useIf==null||useIf();if(!shouldRender){return null;}return(0,_react.createElement)(Group,Object.assign({navigationKey:key},group,{key:key}),children);};})));}}var NavigatorComponent=function NavigatorComponent(){var children=items.map(function(item){return item();});return(0,_jsxRuntime.jsx)(Navigator,Object.assign({},rest,{children:children}));};NavigatorComponent.displayName=displayName;return NavigatorComponent;}function createPathConfigForStaticNavigation(tree,options,auto){var initialScreenConfig;var _createPathConfigForTree=function createPathConfigForTree(t,o,skipInitialDetection){var createPathConfigForScreens=function createPathConfigForScreens(screens,initialRouteName){return Object.fromEntries(Object.entries(screens).sort(function(_ref6,_ref7){var _ref8=_slicedToArray(_ref6,1),a=_ref8[0];var _ref9=_slicedToArray(_ref7,1),b=_ref9[0];if(a===initialRouteName){return-1;}if(b===initialRouteName){return 1;}return 0;}).map(function(_ref10){var _ref11=_slicedToArray(_ref10,2),key=_ref11[0],item=_ref11[1];var screenConfig={};if('linking'in item){if(typeof item.linking==='string'){screenConfig.path=item.linking;}else{Object.assign(screenConfig,item.linking);}if(typeof screenConfig.path==='string'){screenConfig.path=screenConfig.path.split('/').filter(Boolean).join('/');}}var screens;var skipInitialDetectionInChild=skipInitialDetection||screenConfig.path!=null&&screenConfig.path!=='';if('config'in item){screens=_createPathConfigForTree(item,undefined,skipInitialDetectionInChild);}else if('screen'in item&&'config'in item.screen&&(item.screen.config.screens||item.screen.config.groups)){screens=_createPathConfigForTree(item.screen,undefined,skipInitialDetectionInChild);}if(screens){screenConfig.screens=screens;}if(auto&&!screenConfig.screens&&!('linking'in item&&item.linking==null)){if(screenConfig.path!=null){if(!skipInitialDetection&&screenConfig.path===''){initialScreenConfig=undefined;}}else{if(!skipInitialDetection&&initialScreenConfig==null){initialScreenConfig=screenConfig;}screenConfig.path=key.replace(/([A-Z]+)/g,'-$1').replace(/^-/,'').toLowerCase();}}return[key,screenConfig];}).filter(function(_ref12){var _ref13=_slicedToArray(_ref12,2),screen=_ref13[1];return Object.keys(screen).length>0;}));};var screens={};for(var key in t.config){if(key==='screens'&&t.config.screens){var _o$initialRouteName;Object.assign(screens,createPathConfigForScreens(t.config.screens,(_o$initialRouteName=o==null?void 0:o.initialRouteName)!=null?_o$initialRouteName:t.config.initialRouteName));}if(key==='groups'&&t.config.groups){Object.entries(t.config.groups).forEach(function(_ref14){var _o$initialRouteName2;var _ref15=_slicedToArray(_ref14,2),group=_ref15[1];Object.assign(screens,createPathConfigForScreens(group.screens,(_o$initialRouteName2=o==null?void 0:o.initialRouteName)!=null?_o$initialRouteName2:t.config.initialRouteName));});}}if(Object.keys(screens).length===0){return undefined;}return screens;};var screens=_createPathConfigForTree(tree,options,false);if(auto&&initialScreenConfig){initialScreenConfig.path='';}return screens;}","map":{"version":3,"names":["_react","_interopRequireWildcard","require","React","_reactIs","_useRoute","_jsxRuntime","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","MemoizedScreen","memo","_ref","component","route","useRoute","children","createElement","displayName","getItemsFromScreens","Screen","screens","entries","map","_ref2","_ref3","_slicedToArray","name","item","props","useIf","isNavigator","screen","_if","if","rest","_objectWithoutProperties","_excluded","isValidElementType","createComponentForStaticNavigation","Error","element","jsx","shouldRender","assign","tree","Navigator","Group","config","groups","_excluded2","items","key","push","apply","_toConsumableArray","_ref4","_ref5","_ref5$","group","_excluded3","groupItems","navigationKey","NavigatorComponent","createPathConfigForStaticNavigation","options","auto","initialScreenConfig","createPathConfigForTree","o","skipInitialDetection","createPathConfigForScreens","initialRouteName","fromEntries","sort","_ref6","_ref7","_ref8","_ref9","b","_ref10","_ref11","screenConfig","linking","path","split","filter","Boolean","join","skipInitialDetectionInChild","undefined","replace","toLowerCase","_ref12","_ref13","keys","length","_o$initialRouteName","forEach","_ref14","_o$initialRouteName2","_ref15"],"sources":["/Users/primopan/WebstormProjects/AsdLanguauge/AsdLanguage/node_modules/@react-navigation/core/src/StaticNavigation.tsx"],"sourcesContent":["import type { NavigationState, ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\n\nimport type {\n  DefaultNavigatorOptions,\n  EventMapBase,\n  NavigationListBase,\n  NavigatorScreenParams,\n  NavigatorTypeBagBase,\n  PathConfig,\n  RouteConfigComponent,\n  RouteConfigProps,\n  RouteGroupConfig,\n} from './types';\nimport { useRoute } from './useRoute';\n\n/**\n * Flatten a type to remove all type alias names, unions etc.\n * This will show a plain object when hovering over the type.\n */\ntype FlatType<T> = { [K in keyof T]: T[K] } & {};\n\n/**\n * keyof T doesn't work for union types. We can use distributive conditional types instead.\n * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\ntype KeysOf<T> = T extends {} ? keyof T : never;\n\n/**\n * We get a union type when using keyof, but we want an intersection instead.\n * https://stackoverflow.com/a/50375286/1665026\n */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never;\n\ntype UnknownToUndefined<T> = unknown extends T ? undefined : T;\n\ntype ParamsForScreenComponent<T> = T extends {\n  screen: React.ComponentType<{ route: { params: infer P } }>;\n}\n  ? P\n  : T extends React.ComponentType<{ route: { params: infer P } }>\n    ? P\n    : undefined;\n\ntype ParamsForScreen<T> = T extends { screen: StaticNavigation<any, any, any> }\n  ? NavigatorScreenParams<StaticParamList<T['screen']>> | undefined\n  : T extends StaticNavigation<any, any, any>\n    ? NavigatorScreenParams<StaticParamList<T>> | undefined\n    : UnknownToUndefined<ParamsForScreenComponent<T>>;\n\ntype ParamListForScreens<Screens> = {\n  [Key in KeysOf<Screens>]: ParamsForScreen<Screens[Key]>;\n};\n\ntype ParamListForGroups<\n  Groups extends\n    | Readonly<{\n        [key: string]: {\n          screens: StaticConfigScreens<\n            ParamListBase,\n            NavigationState,\n            {},\n            EventMapBase,\n            any\n          >;\n        };\n      }>\n    | undefined,\n> = Groups extends {\n  [key: string]: {\n    screens: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      any\n    >;\n  };\n}\n  ? ParamListForScreens<UnionToIntersection<Groups[keyof Groups]['screens']>>\n  : {};\n\ntype StaticRouteConfig<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  Navigation,\n> = RouteConfigProps<\n  ParamList,\n  RouteName,\n  State,\n  ScreenOptions,\n  EventMap,\n  Navigation\n> &\n  RouteConfigComponent<ParamList, RouteName>;\n\ntype StaticConfigScreens<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = {\n  [RouteName in keyof ParamList]:\n    | React.ComponentType<any>\n    | StaticNavigation<any, any, any>\n    | (Omit<\n        StaticRouteConfig<\n          ParamList,\n          RouteName,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList[RouteName]\n        >,\n        'name' | 'component' | 'getComponent' | 'children'\n      > & {\n        /**\n         * Callback to determine whether the screen should be rendered or not.\n         * This can be useful for conditional rendering of screens,\n         * e.g. - if you want to render a different screen for logged in users.\n         *\n         * You can use a custom hook to use custom logic to determine the return value.\n         *\n         * @example\n         * ```js\n         * if: useIsLoggedIn\n         * ```\n         */\n        if?: () => boolean;\n        /**\n         * Linking config for the screen.\n         * This can be a string to specify the path, or an object with more options.\n         *\n         * @example\n         * ```js\n         * linking: {\n         *   path: 'profile/:id',\n         *   exact: true,\n         * },\n         * ```\n         */\n        linking?: PathConfig<ParamList> | string;\n        /**\n         * Static navigation config or Component to render for the screen.\n         */\n        screen: StaticNavigation<any, any, any> | React.ComponentType<any>;\n      });\n};\n\ntype GroupConfig<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = Omit<\n  RouteGroupConfig<ParamList, ScreenOptions, NavigationList[keyof ParamList]>,\n  'screens' | 'children'\n> & {\n  /**\n   * Callback to determine whether the screens in the group should be rendered or not.\n   * This can be useful for conditional rendering of group of screens.\n   */\n  if?: () => boolean;\n  /**\n   * Static navigation config or Component to render for the screen.\n   */\n  screens: StaticConfigScreens<\n    ParamList,\n    State,\n    ScreenOptions,\n    EventMap,\n    NavigationList\n  >;\n};\n\nexport type StaticConfig<Bag extends NavigatorTypeBagBase> =\n  StaticConfigInternal<\n    Bag['ParamList'],\n    Bag['NavigatorID'],\n    Bag['State'],\n    Bag['ScreenOptions'],\n    Bag['EventMap'],\n    Bag['NavigationList'],\n    Bag['Navigator']\n  >;\n\ntype StaticConfigInternal<\n  ParamList extends ParamListBase,\n  NavigatorID extends string | undefined,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n  Navigator extends React.ComponentType<any>,\n> = Omit<\n  Omit<\n    React.ComponentProps<Navigator>,\n    keyof DefaultNavigatorOptions<\n      ParamListBase,\n      string | undefined,\n      NavigationState,\n      {},\n      EventMapBase,\n      NavigationList[keyof ParamList]\n    >\n  > &\n    DefaultNavigatorOptions<\n      ParamList,\n      NavigatorID,\n      State,\n      ScreenOptions,\n      EventMap,\n      NavigationList[keyof ParamList]\n    >,\n  'screens' | 'children'\n> &\n  (\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups?: {\n          [key: string]: GroupConfig<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens?: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups: {\n          [key: string]: GroupConfig<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n  );\n\n/**\n * Props for a screen component which is rendered by a static navigator.\n * Takes the route params as a generic argument.\n */\nexport type StaticScreenProps<T extends Record<string, unknown> | undefined> = {\n  route: {\n    params: T;\n  };\n};\n\n/**\n * Infer the param list from the static navigation config.\n */\nexport type StaticParamList<\n  T extends {\n    readonly config: {\n      readonly screens?: Record<string, any>;\n      readonly groups?: {\n        [key: string]: {\n          screens: Record<string, any>;\n        };\n      };\n    };\n  },\n> = FlatType<\n  ParamListForScreens<T['config']['screens']> &\n    ParamListForGroups<T['config']['groups']>\n>;\n\nexport type StaticNavigation<NavigatorProps, GroupProps, ScreenProps> = {\n  Navigator: React.ComponentType<NavigatorProps>;\n  Group: React.ComponentType<GroupProps>;\n  Screen: React.ComponentType<ScreenProps>;\n  config: StaticConfig<NavigatorTypeBagBase>;\n};\n\nconst MemoizedScreen = React.memo(\n  <T extends React.ComponentType<any>>({ component }: { component: T }) => {\n    const route = useRoute();\n    const children = React.createElement(component, { route });\n\n    return children;\n  }\n);\n\nMemoizedScreen.displayName = 'Memo(Screen)';\n\nconst getItemsFromScreens = (\n  Screen: React.ComponentType<any>,\n  screens: StaticConfigScreens<any, any, any, any, any>\n) => {\n  return Object.entries(screens).map(([name, item]) => {\n    let component: React.ComponentType<any> | undefined;\n    let props: {} = {};\n    let useIf: (() => boolean) | undefined;\n\n    let isNavigator = false;\n\n    if ('screen' in item) {\n      const { screen, if: _if, ...rest } = item;\n\n      useIf = _if;\n      props = rest;\n\n      if (isValidElementType(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(\n          screen,\n          `${name}Navigator`\n        );\n      }\n    } else if (isValidElementType(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n\n    if (component == null) {\n      throw new Error(\n        `Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`\n      );\n    }\n\n    const element = isNavigator ? (\n      React.createElement(component, {})\n    ) : (\n      <MemoizedScreen component={component} />\n    );\n\n    return () => {\n      const shouldRender = useIf == null || useIf();\n\n      if (!shouldRender) {\n        return null;\n      }\n\n      return (\n        <Screen key={name} name={name} {...props}>\n          {() => element}\n        </Screen>\n      );\n    };\n  });\n};\n\n/**\n * Create a component that renders a navigator based on the static configuration.\n *\n * @param tree Static navigation config.\n * @param displayName Name of the component to be displayed in React DevTools.\n * @returns A component which renders the navigator.\n */\nexport function createComponentForStaticNavigation(\n  tree: StaticNavigation<any, any, any>,\n  displayName: string\n): React.ComponentType<{}> {\n  const { Navigator, Group, Screen, config } = tree;\n  const { screens, groups, ...rest } = config;\n\n  if (screens == null && groups == null) {\n    throw new Error(\n      \"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\"\n    );\n  }\n\n  const items: (() => JSX.Element | null)[] = [];\n\n  // Loop through the config to find screens and groups\n  // So we add the screens and groups in the same order as they are defined\n  for (const key in config) {\n    if (key === 'screens' && screens) {\n      items.push(...getItemsFromScreens(Screen, screens));\n    }\n\n    if (key === 'groups' && groups) {\n      items.push(\n        ...Object.entries(groups).map(([key, { if: useIf, ...group }]) => {\n          const groupItems = getItemsFromScreens(Screen, group.screens);\n\n          return () => {\n            // Call unconditionally since screen configs may contain `useIf` hooks\n            const children = groupItems.map((item) => item());\n\n            const shouldRender = useIf == null || useIf();\n\n            if (!shouldRender) {\n              return null;\n            }\n\n            return (\n              <Group navigationKey={key} {...group} key={key}>\n                {children}\n              </Group>\n            );\n          };\n        })\n      );\n    }\n  }\n\n  const NavigatorComponent = () => {\n    const children = items.map((item) => item());\n\n    return <Navigator {...rest}>{children}</Navigator>;\n  };\n\n  NavigatorComponent.displayName = displayName;\n\n  return NavigatorComponent;\n}\n\ntype TreeForPathConfig = {\n  config: {\n    initialRouteName?: string;\n    screens?: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      Record<string, unknown>\n    >;\n    groups?: {\n      [key: string]: {\n        screens: StaticConfigScreens<\n          ParamListBase,\n          NavigationState,\n          {},\n          EventMapBase,\n          Record<string, unknown>\n        >;\n      };\n    };\n  };\n};\n\n/**\n * Create a path config object from a static navigation config for deep linking.\n *\n * @param tree Static navigation config.\n * @param options Additional options from `linking.config`.\n * @param auto Whether to automatically generate paths for leaf screens.\n * @returns Path config object to use in linking config.\n *\n * @example\n * ```js\n * const config = {\n *   screens: {\n *     Home: {\n *       screens: createPathConfigForStaticNavigation(HomeTabs),\n *     },\n *   },\n * };\n * ```\n */\nexport function createPathConfigForStaticNavigation(\n  tree: TreeForPathConfig,\n  options?: {\n    initialRouteName?: string;\n  },\n  auto?: boolean\n) {\n  let initialScreenConfig: PathConfig<ParamListBase> | undefined;\n\n  const createPathConfigForTree = (\n    t: TreeForPathConfig,\n    o: { initialRouteName?: string } | undefined,\n    // If a screen is a leaf node, but inside a screen with path,\n    // It should not be used for initial detection\n    skipInitialDetection: boolean\n  ) => {\n    const createPathConfigForScreens = (\n      screens: StaticConfigScreens<\n        ParamListBase,\n        NavigationState,\n        {},\n        EventMapBase,\n        Record<string, unknown>\n      >,\n      initialRouteName: string | undefined\n    ) => {\n      return Object.fromEntries(\n        Object.entries(screens)\n          // Re-order to move the initial route to the front\n          // This way we can detect the initial route correctly\n          .sort(([a], [b]) => {\n            if (a === initialRouteName) {\n              return -1;\n            }\n\n            if (b === initialRouteName) {\n              return 1;\n            }\n\n            return 0;\n          })\n          .map(([key, item]) => {\n            const screenConfig: PathConfig<ParamListBase> = {};\n\n            if ('linking' in item) {\n              if (typeof item.linking === 'string') {\n                screenConfig.path = item.linking;\n              } else {\n                Object.assign(screenConfig, item.linking);\n              }\n\n              if (typeof screenConfig.path === 'string') {\n                // Normalize the path to remove leading and trailing slashes\n                screenConfig.path = screenConfig.path\n                  .split('/')\n                  .filter(Boolean)\n                  .join('/');\n              }\n            }\n\n            let screens;\n\n            const skipInitialDetectionInChild =\n              skipInitialDetection ||\n              (screenConfig.path != null && screenConfig.path !== '');\n\n            if ('config' in item) {\n              screens = createPathConfigForTree(\n                item,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            } else if (\n              'screen' in item &&\n              'config' in item.screen &&\n              (item.screen.config.screens || item.screen.config.groups)\n            ) {\n              screens = createPathConfigForTree(\n                item.screen,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            }\n\n            if (screens) {\n              screenConfig.screens = screens;\n            }\n\n            if (\n              auto &&\n              !screenConfig.screens &&\n              // Skip generating path for screens that specify linking config as `undefined` or `null` explicitly\n              !('linking' in item && item.linking == null)\n            ) {\n              if (screenConfig.path != null) {\n                if (!skipInitialDetection && screenConfig.path === '') {\n                  // We encounter a leaf screen with empty path,\n                  // Clear the initial screen config as it's not needed anymore\n                  initialScreenConfig = undefined;\n                }\n              } else {\n                if (!skipInitialDetection && initialScreenConfig == null) {\n                  initialScreenConfig = screenConfig;\n                }\n\n                screenConfig.path = key\n                  .replace(/([A-Z]+)/g, '-$1')\n                  .replace(/^-/, '')\n                  .toLowerCase();\n              }\n            }\n\n            return [key, screenConfig] as const;\n          })\n          .filter(([, screen]) => Object.keys(screen).length > 0)\n      );\n    };\n\n    const screens = {};\n\n    // Loop through the config to find screens and groups\n    // So we add the screens and groups in the same order as they are defined\n    for (const key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        Object.assign(\n          screens,\n          createPathConfigForScreens(\n            t.config.screens,\n            o?.initialRouteName ?? t.config.initialRouteName\n          )\n        );\n      }\n\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(([, group]) => {\n          Object.assign(\n            screens,\n            createPathConfigForScreens(\n              group.screens,\n              o?.initialRouteName ?? t.config.initialRouteName\n            )\n          );\n        });\n      }\n    }\n\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n\n    return screens;\n  };\n\n  const screens = createPathConfigForTree(tree, options, false);\n\n  if (auto && initialScreenConfig) {\n    initialScreenConfig.path = '';\n  }\n\n  return screens;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}