{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = findNodeHandle;\nvar _utils = require(\"./web/utils\");\nfunction findNodeHandle(viewRef) {\n  if ((viewRef === null || viewRef === void 0 ? void 0 : viewRef.viewTag) !== undefined) {\n    return findNodeHandle(viewRef.viewTag);\n  }\n  if (viewRef instanceof Element) {\n    if (viewRef.style.display === 'contents') {\n      return findNodeHandle(viewRef.firstChild);\n    }\n    return viewRef;\n  }\n  if ((0, _utils.isRNSVGElement)(viewRef)) {\n    return viewRef.elementRef.current;\n  }\n  var element = viewRef === null || viewRef === void 0 ? void 0 : viewRef.current;\n  while (element && element.style.display === 'contents') {\n    element = element.firstChild;\n  }\n  return element;\n}","map":{"version":3,"names":["_utils","require","findNodeHandle","viewRef","viewTag","undefined","Element","style","display","firstChild","isRNSVGElement","elementRef","current","element"],"sources":["/Users/primopan/WebstormProjects/AsdLanguauge/AsdLanguage/node_modules/react-native-gesture-handler/lib/module/findNodeHandle.web.ts"],"sourcesContent":["import type { GestureHandlerRef, SVGRef } from './web/interfaces';\nimport { isRNSVGElement } from './web/utils';\n\nexport default function findNodeHandle(\n  viewRef: GestureHandlerRef | SVGRef | HTMLElement | SVGElement\n): HTMLElement | SVGElement | number {\n  // Old API assumes that child handler is HTMLElement.\n  // However, if we nest handlers, we will get ref to another handler.\n  // In that case, we want to recursively call findNodeHandle with new handler viewTag (which can also be ref to another handler).\n  if ((viewRef as GestureHandlerRef)?.viewTag !== undefined) {\n    return findNodeHandle((viewRef as GestureHandlerRef).viewTag);\n  }\n\n  if (viewRef instanceof Element) {\n    if (viewRef.style.display === 'contents') {\n      return findNodeHandle(viewRef.firstChild as HTMLElement);\n    }\n\n    return viewRef;\n  }\n\n  if (isRNSVGElement(viewRef)) {\n    return (viewRef as SVGRef).elementRef.current;\n  }\n\n  // In new API, we receive ref object which `current` field points to  wrapper `div` with `display: contents;`.\n  // We want to return the first descendant (in DFS order) that doesn't have this property.\n  let element = (viewRef as GestureHandlerRef)?.current;\n\n  while (element && element.style.display === 'contents') {\n    element = element.firstChild as HTMLElement;\n  }\n\n  return element;\n}\n"],"mappings":";;;;AACA,IAAAA,MAAA,GAAAC,OAAA;AAEe,SAASC,cAATA,CACbC,OADa,EAEsB;EAInC,IAAI,CAACA,OAAD,aAACA,OAAD,uBAACA,OAAD,CAAgCC,OAAhC,MAA4CC,SAAhD,EAA2D;IACzD,OAAOH,cAAc,CAAEC,OAAD,CAA+BC,OAAhC,CAArB;EACD;EAED,IAAID,OAAO,YAAYG,OAAvB,EAAgC;IAC9B,IAAIH,OAAO,CAACI,KAAR,CAAcC,OAAd,KAA0B,UAA9B,EAA0C;MACxC,OAAON,cAAc,CAACC,OAAO,CAACM,UAAT,CAArB;IACD;IAED,OAAON,OAAP;EACD;EAED,IAAI,IAAAO,qBAAc,EAACP,OAAD,CAAlB,EAA6B;IAC3B,OAAQA,OAAD,CAAoBQ,UAApB,CAA+BC,OAAtC;EACD;EAID,IAAIC,OAAO,GAAIV,OAAJ,aAAIA,OAAJ,uBAAIA,OAAD,CAAgCS,OAA9C;EAEA,OAAOC,OAAO,IAAIA,OAAO,CAACN,KAAR,CAAcC,OAAd,KAA0B,UAA5C,EAAwD;IACtDK,OAAO,GAAGA,OAAO,CAACJ,UAAlB;EACD;EAED,OAAOI,OAAP;AACD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}