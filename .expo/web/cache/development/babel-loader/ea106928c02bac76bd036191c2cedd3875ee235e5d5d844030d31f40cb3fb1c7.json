{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useAnimatedGesture = useAnimatedGesture;\nvar _gesture = require(\"../gesture\");\nvar _reanimatedWrapper = require(\"../reanimatedWrapper\");\nvar _gestureStateManager = require(\"../gestureStateManager\");\nvar _State = require(\"../../../State\");\nvar _TouchEventType = require(\"../../../TouchEventType\");\nvar _utils = require(\"../../../utils\");\nfunction getHandler(type, gesture) {\n  'worklet';\n\n  switch (type) {\n    case _gesture.CALLBACK_TYPE.BEGAN:\n      return gesture.onBegin;\n    case _gesture.CALLBACK_TYPE.START:\n      return gesture.onStart;\n    case _gesture.CALLBACK_TYPE.UPDATE:\n      return gesture.onUpdate;\n    case _gesture.CALLBACK_TYPE.CHANGE:\n      return gesture.onChange;\n    case _gesture.CALLBACK_TYPE.END:\n      return gesture.onEnd;\n    case _gesture.CALLBACK_TYPE.FINALIZE:\n      return gesture.onFinalize;\n    case _gesture.CALLBACK_TYPE.TOUCHES_DOWN:\n      return gesture.onTouchesDown;\n    case _gesture.CALLBACK_TYPE.TOUCHES_MOVE:\n      return gesture.onTouchesMove;\n    case _gesture.CALLBACK_TYPE.TOUCHES_UP:\n      return gesture.onTouchesUp;\n    case _gesture.CALLBACK_TYPE.TOUCHES_CANCELLED:\n      return gesture.onTouchesCancelled;\n  }\n}\nfunction touchEventTypeToCallbackType(eventType) {\n  'worklet';\n\n  switch (eventType) {\n    case _TouchEventType.TouchEventType.TOUCHES_DOWN:\n      return _gesture.CALLBACK_TYPE.TOUCHES_DOWN;\n    case _TouchEventType.TouchEventType.TOUCHES_MOVE:\n      return _gesture.CALLBACK_TYPE.TOUCHES_MOVE;\n    case _TouchEventType.TouchEventType.TOUCHES_UP:\n      return _gesture.CALLBACK_TYPE.TOUCHES_UP;\n    case _TouchEventType.TouchEventType.TOUCHES_CANCELLED:\n      return _gesture.CALLBACK_TYPE.TOUCHES_CANCELLED;\n  }\n  return _gesture.CALLBACK_TYPE.UNDEFINED;\n}\nfunction runWorklet(type, gesture, event) {\n  'worklet';\n\n  var handler = getHandler(type, gesture);\n  if (gesture.isWorklet[type]) {\n    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      args[_key - 3] = arguments[_key];\n    }\n    handler === null || handler === void 0 ? void 0 : handler.apply(void 0, [event].concat(args));\n  } else if (handler) {\n    console.warn((0, _utils.tagMessage)('Animated gesture callback must be a worklet'));\n  }\n}\nfunction isStateChangeEvent(event) {\n  'worklet';\n  return event.oldState != null;\n}\nfunction isTouchEvent(event) {\n  'worklet';\n\n  return event.eventType != null;\n}\nfunction useAnimatedGesture(preparedGesture, needsRebuild) {\n  if (!_reanimatedWrapper.Reanimated) {\n    return;\n  }\n  var sharedHandlersCallbacks = _reanimatedWrapper.Reanimated.useSharedValue(null);\n  var lastUpdateEvent = _reanimatedWrapper.Reanimated.useSharedValue([]);\n  var stateControllers = [];\n  var callback = function callback(event) {\n    'worklet';\n\n    var currentCallback = sharedHandlersCallbacks.value;\n    if (!currentCallback) {\n      return;\n    }\n    for (var i = 0; i < currentCallback.length; i++) {\n      var gesture = currentCallback[i];\n      if (event.handlerTag !== gesture.handlerTag) {\n        continue;\n      }\n      if (isStateChangeEvent(event)) {\n        if (event.oldState === _State.State.UNDETERMINED && event.state === _State.State.BEGAN) {\n          runWorklet(_gesture.CALLBACK_TYPE.BEGAN, gesture, event);\n        } else if ((event.oldState === _State.State.BEGAN || event.oldState === _State.State.UNDETERMINED) && event.state === _State.State.ACTIVE) {\n          runWorklet(_gesture.CALLBACK_TYPE.START, gesture, event);\n          lastUpdateEvent.value[gesture.handlerTag] = undefined;\n        } else if (event.oldState !== event.state && event.state === _State.State.END) {\n          if (event.oldState === _State.State.ACTIVE) {\n            runWorklet(_gesture.CALLBACK_TYPE.END, gesture, event, true);\n          }\n          runWorklet(_gesture.CALLBACK_TYPE.FINALIZE, gesture, event, true);\n        } else if ((event.state === _State.State.FAILED || event.state === _State.State.CANCELLED) && event.state !== event.oldState) {\n          if (event.oldState === _State.State.ACTIVE) {\n            runWorklet(_gesture.CALLBACK_TYPE.END, gesture, event, false);\n          }\n          runWorklet(_gesture.CALLBACK_TYPE.FINALIZE, gesture, event, false);\n        }\n      } else if (isTouchEvent(event)) {\n        if (!stateControllers[i]) {\n          stateControllers[i] = _gestureStateManager.GestureStateManager.create(event.handlerTag);\n        }\n        if (event.eventType !== _TouchEventType.TouchEventType.UNDETERMINED) {\n          runWorklet(touchEventTypeToCallbackType(event.eventType), gesture, event, stateControllers[i]);\n        }\n      } else {\n        runWorklet(_gesture.CALLBACK_TYPE.UPDATE, gesture, event);\n        if (gesture.onChange && gesture.changeEventCalculator) {\n          var _gesture$changeEventC;\n          runWorklet(_gesture.CALLBACK_TYPE.CHANGE, gesture, (_gesture$changeEventC = gesture.changeEventCalculator) === null || _gesture$changeEventC === void 0 ? void 0 : _gesture$changeEventC.call(gesture, event, lastUpdateEvent.value[gesture.handlerTag]));\n          lastUpdateEvent.value[gesture.handlerTag] = event;\n        }\n      }\n    }\n  };\n  var event = _reanimatedWrapper.Reanimated.useEvent(callback, ['onGestureHandlerStateChange', 'onGestureHandlerEvent'], needsRebuild);\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}","map":{"version":3,"names":["_gesture","require","_reanimatedWrapper","_gestureStateManager","_State","_TouchEventType","_utils","getHandler","type","gesture","CALLBACK_TYPE","BEGAN","onBegin","START","onStart","UPDATE","onUpdate","CHANGE","onChange","END","onEnd","FINALIZE","onFinalize","TOUCHES_DOWN","onTouchesDown","TOUCHES_MOVE","onTouchesMove","TOUCHES_UP","onTouchesUp","TOUCHES_CANCELLED","onTouchesCancelled","touchEventTypeToCallbackType","eventType","TouchEventType","UNDEFINED","runWorklet","event","handler","isWorklet","_len","arguments","length","args","Array","_key","apply","concat","console","warn","tagMessage","isStateChangeEvent","oldState","isTouchEvent","useAnimatedGesture","preparedGesture","needsRebuild","Reanimated","sharedHandlersCallbacks","useSharedValue","lastUpdateEvent","stateControllers","callback","currentCallback","value","i","handlerTag","State","UNDETERMINED","state","ACTIVE","undefined","FAILED","CANCELLED","GestureStateManager","create","changeEventCalculator","_gesture$changeEventC","call","useEvent","animatedEventHandler","animatedHandlers"],"sources":["/Users/primopan/WebstormProjects/AsdLanguauge/AsdLanguage/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector/useAnimatedGesture.ts"],"sourcesContent":["import { HandlerCallbacks, CALLBACK_TYPE } from '../gesture';\nimport { Reanimated } from '../reanimatedWrapper';\nimport {\n  GestureTouchEvent,\n  GestureUpdateEvent,\n  GestureStateChangeEvent,\n} from '../../gestureHandlerCommon';\nimport {\n  GestureStateManager,\n  GestureStateManagerType,\n} from '../gestureStateManager';\nimport { State } from '../../../State';\nimport { TouchEventType } from '../../../TouchEventType';\nimport { tagMessage } from '../../../utils';\nimport { AttachedGestureState } from './types';\n\nfunction getHandler(\n  type: CALLBACK_TYPE,\n  gesture: HandlerCallbacks<Record<string, unknown>>\n) {\n  'worklet';\n  switch (type) {\n    case CALLBACK_TYPE.BEGAN:\n      return gesture.onBegin;\n    case CALLBACK_TYPE.START:\n      return gesture.onStart;\n    case CALLBACK_TYPE.UPDATE:\n      return gesture.onUpdate;\n    case CALLBACK_TYPE.CHANGE:\n      return gesture.onChange;\n    case CALLBACK_TYPE.END:\n      return gesture.onEnd;\n    case CALLBACK_TYPE.FINALIZE:\n      return gesture.onFinalize;\n    case CALLBACK_TYPE.TOUCHES_DOWN:\n      return gesture.onTouchesDown;\n    case CALLBACK_TYPE.TOUCHES_MOVE:\n      return gesture.onTouchesMove;\n    case CALLBACK_TYPE.TOUCHES_UP:\n      return gesture.onTouchesUp;\n    case CALLBACK_TYPE.TOUCHES_CANCELLED:\n      return gesture.onTouchesCancelled;\n  }\n}\n\nfunction touchEventTypeToCallbackType(\n  eventType: TouchEventType\n): CALLBACK_TYPE {\n  'worklet';\n  switch (eventType) {\n    case TouchEventType.TOUCHES_DOWN:\n      return CALLBACK_TYPE.TOUCHES_DOWN;\n    case TouchEventType.TOUCHES_MOVE:\n      return CALLBACK_TYPE.TOUCHES_MOVE;\n    case TouchEventType.TOUCHES_UP:\n      return CALLBACK_TYPE.TOUCHES_UP;\n    case TouchEventType.TOUCHES_CANCELLED:\n      return CALLBACK_TYPE.TOUCHES_CANCELLED;\n  }\n  return CALLBACK_TYPE.UNDEFINED;\n}\n\nfunction runWorklet(\n  type: CALLBACK_TYPE,\n  gesture: HandlerCallbacks<Record<string, unknown>>,\n  event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\n  ...args: unknown[]\n) {\n  'worklet';\n  const handler = getHandler(type, gesture);\n  if (gesture.isWorklet[type]) {\n    // @ts-ignore Logic below makes sure the correct event is send to the\n    // correct handler.\n    handler?.(event, ...args);\n  } else if (handler) {\n    console.warn(tagMessage('Animated gesture callback must be a worklet'));\n  }\n}\n\nfunction isStateChangeEvent(\n  event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n): event is GestureStateChangeEvent {\n  'worklet';\n  // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\n  return event.oldState != null;\n}\n\nfunction isTouchEvent(\n  event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n): event is GestureTouchEvent {\n  'worklet';\n  return event.eventType != null;\n}\n\nexport function useAnimatedGesture(\n  preparedGesture: AttachedGestureState,\n  needsRebuild: boolean\n) {\n  if (!Reanimated) {\n    return;\n  }\n\n  // Hooks are called conditionally, but the condition is whether the\n  // react-native-reanimated is installed, which shouldn't change while running\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  >(null);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const lastUpdateEvent = Reanimated.useSharedValue<\n    (GestureUpdateEvent | undefined)[]\n  >([]);\n\n  // not every gesture needs a state controller, init them lazily\n  const stateControllers: GestureStateManagerType[] = [];\n\n  const callback = (\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\n  ) => {\n    'worklet';\n\n    const currentCallback = sharedHandlersCallbacks.value;\n    if (!currentCallback) {\n      return;\n    }\n\n    for (let i = 0; i < currentCallback.length; i++) {\n      const gesture = currentCallback[i];\n\n      if (event.handlerTag !== gesture.handlerTag) {\n        continue;\n      }\n\n      if (isStateChangeEvent(event)) {\n        if (\n          event.oldState === State.UNDETERMINED &&\n          event.state === State.BEGAN\n        ) {\n          runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\n        } else if (\n          (event.oldState === State.BEGAN ||\n            event.oldState === State.UNDETERMINED) &&\n          event.state === State.ACTIVE\n        ) {\n          runWorklet(CALLBACK_TYPE.START, gesture, event);\n          lastUpdateEvent.value[gesture.handlerTag] = undefined;\n        } else if (\n          event.oldState !== event.state &&\n          event.state === State.END\n        ) {\n          if (event.oldState === State.ACTIVE) {\n            runWorklet(CALLBACK_TYPE.END, gesture, event, true);\n          }\n          runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\n        } else if (\n          (event.state === State.FAILED || event.state === State.CANCELLED) &&\n          event.state !== event.oldState\n        ) {\n          if (event.oldState === State.ACTIVE) {\n            runWorklet(CALLBACK_TYPE.END, gesture, event, false);\n          }\n          runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\n        }\n      } else if (isTouchEvent(event)) {\n        if (!stateControllers[i]) {\n          stateControllers[i] = GestureStateManager.create(event.handlerTag);\n        }\n\n        if (event.eventType !== TouchEventType.UNDETERMINED) {\n          runWorklet(\n            touchEventTypeToCallbackType(event.eventType),\n            gesture,\n            event,\n            stateControllers[i]\n          );\n        }\n      } else {\n        runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\n\n        if (gesture.onChange && gesture.changeEventCalculator) {\n          runWorklet(\n            CALLBACK_TYPE.CHANGE,\n            gesture,\n            gesture.changeEventCalculator?.(\n              event,\n              lastUpdateEvent.value[gesture.handlerTag]\n            )\n          );\n\n          lastUpdateEvent.value[gesture.handlerTag] = event;\n        }\n      }\n    }\n  };\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const event = Reanimated.useEvent(\n    callback,\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\n    needsRebuild\n  );\n\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\n"],"mappings":";;;;AAAA,IAAAA,QAAA,GAAAC,OAAA;AACA,IAAAC,kBAAA,GAAAD,OAAA;AAMA,IAAAE,oBAAA,GAAAF,OAAA;AAIA,IAAAG,MAAA,GAAAH,OAAA;AACA,IAAAI,eAAA,GAAAJ,OAAA;AACA,IAAAK,MAAA,GAAAL,OAAA;AAGA,SAASM,UAATA,CACEC,IADF,EAEEC,OAFF,EAGE;EACA;;EACA,QAAQD,IAAR;IACE,KAAKE,sBAAa,CAACC,KAAnB;MACE,OAAOF,OAAO,CAACG,OAAf;IACF,KAAKF,sBAAa,CAACG,KAAnB;MACE,OAAOJ,OAAO,CAACK,OAAf;IACF,KAAKJ,sBAAa,CAACK,MAAnB;MACE,OAAON,OAAO,CAACO,QAAf;IACF,KAAKN,sBAAa,CAACO,MAAnB;MACE,OAAOR,OAAO,CAACS,QAAf;IACF,KAAKR,sBAAa,CAACS,GAAnB;MACE,OAAOV,OAAO,CAACW,KAAf;IACF,KAAKV,sBAAa,CAACW,QAAnB;MACE,OAAOZ,OAAO,CAACa,UAAf;IACF,KAAKZ,sBAAa,CAACa,YAAnB;MACE,OAAOd,OAAO,CAACe,aAAf;IACF,KAAKd,sBAAa,CAACe,YAAnB;MACE,OAAOhB,OAAO,CAACiB,aAAf;IACF,KAAKhB,sBAAa,CAACiB,UAAnB;MACE,OAAOlB,OAAO,CAACmB,WAAf;IACF,KAAKlB,sBAAa,CAACmB,iBAAnB;MACE,OAAOpB,OAAO,CAACqB,kBAAf;EApBJ;AAsBD;AAED,SAASC,4BAATA,CACEC,SADF,EAEiB;EACf;;EACA,QAAQA,SAAR;IACE,KAAKC,8BAAc,CAACV,YAApB;MACE,OAAOb,sBAAa,CAACa,YAArB;IACF,KAAKU,8BAAc,CAACR,YAApB;MACE,OAAOf,sBAAa,CAACe,YAArB;IACF,KAAKQ,8BAAc,CAACN,UAApB;MACE,OAAOjB,sBAAa,CAACiB,UAArB;IACF,KAAKM,8BAAc,CAACJ,iBAApB;MACE,OAAOnB,sBAAa,CAACmB,iBAArB;EARJ;EAUA,OAAOnB,sBAAa,CAACwB,SAArB;AACD;AAED,SAASC,UAATA,CACE3B,IADF,EAEEC,OAFF,EAGE2B,KAHF,EAKE;EACA;;EACA,IAAMC,OAAO,GAAG9B,UAAU,CAACC,IAAD,EAAOC,OAAP,CAA1B;EACA,IAAIA,OAAO,CAAC6B,SAAR,CAAkB9B,IAAlB,CAAJ,EAA6B;IAAA,SAAA+B,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAJ1BC,IAJL,OAAAC,KAAA,CAAAJ,IAAA,OAAAA,IAAA,WAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;MAIKF,IAJL,CAAAE,IAAA,QAAAJ,SAAA,CAAAI,IAAA;IAAA;IAWIP,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAAQ,KAAA,UAAGT,KAAH,EAAAU,MAAA,CAAaJ,IAAb,EAAP;EACD,CAJD,MAIO,IAAIL,OAAJ,EAAa;IAClBU,OAAO,CAACC,IAAR,CAAa,IAAAC,iBAAU,EAAC,6CAAD,CAAvB;EACD;AACF;AAED,SAASC,kBAATA,CACEd,KADF,EAEoC;EAClC;EAEA,OAAOA,KAAK,CAACe,QAAN,IAAkB,IAAzB;AACD;AAED,SAASC,YAATA,CACEhB,KADF,EAE8B;EAC5B;;EACA,OAAOA,KAAK,CAACJ,SAAN,IAAmB,IAA1B;AACD;AAEM,SAASqB,kBAATA,CACLC,eADK,EAELC,YAFK,EAGL;EACA,IAAI,CAACC,6BAAL,EAAiB;IACf;EACD;EAKD,IAAMC,uBAAuB,GAAGD,6BAAU,CAACE,cAAX,CAE9B,IAF8B,CAAhC;EAKA,IAAMC,eAAe,GAAGH,6BAAU,CAACE,cAAX,CAEtB,EAFsB,CAAxB;EAKA,IAAME,gBAA2C,GAAG,EAApD;EAEA,IAAMC,QAAQ,GACZ,SADIA,QAAQA,CACZzB,KADe,EAEZ;IACH;;IAEA,IAAM0B,eAAe,GAAGL,uBAAuB,CAACM,KAAhD;IACA,IAAI,CAACD,eAAL,EAAsB;MACpB;IACD;IAED,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,eAAe,CAACrB,MAApC,EAA4CuB,CAAC,EAA7C,EAAiD;MAC/C,IAAMvD,OAAO,GAAGqD,eAAe,CAACE,CAAD,CAA/B;MAEA,IAAI5B,KAAK,CAAC6B,UAAN,KAAqBxD,OAAO,CAACwD,UAAjC,EAA6C;QAC3C;MACD;MAED,IAAIf,kBAAkB,CAACd,KAAD,CAAtB,EAA+B;QAC7B,IACEA,KAAK,CAACe,QAAN,KAAmBe,YAAK,CAACC,YAAzB,IACA/B,KAAK,CAACgC,KAAN,KAAgBF,YAAK,CAACvD,KAFxB,EAGE;UACAwB,UAAU,CAACzB,sBAAa,CAACC,KAAf,EAAsBF,OAAtB,EAA+B2B,KAA/B,CAAV;QACD,CALD,MAKO,IACL,CAACA,KAAK,CAACe,QAAN,KAAmBe,YAAK,CAACvD,KAAzB,IACCyB,KAAK,CAACe,QAAN,KAAmBe,YAAK,CAACC,YAD3B,KAEA/B,KAAK,CAACgC,KAAN,KAAgBF,YAAK,CAACG,MAHjB,EAIL;UACAlC,UAAU,CAACzB,sBAAa,CAACG,KAAf,EAAsBJ,OAAtB,EAA+B2B,KAA/B,CAAV;UACAuB,eAAe,CAACI,KAAhB,CAAsBtD,OAAO,CAACwD,UAA9B,IAA4CK,SAA5C;QACD,CAPM,MAOA,IACLlC,KAAK,CAACe,QAAN,KAAmBf,KAAK,CAACgC,KAAzB,IACAhC,KAAK,CAACgC,KAAN,KAAgBF,YAAK,CAAC/C,GAFjB,EAGL;UACA,IAAIiB,KAAK,CAACe,QAAN,KAAmBe,YAAK,CAACG,MAA7B,EAAqC;YACnClC,UAAU,CAACzB,sBAAa,CAACS,GAAf,EAAoBV,OAApB,EAA6B2B,KAA7B,EAAoC,IAApC,CAAV;UACD;UACDD,UAAU,CAACzB,sBAAa,CAACW,QAAf,EAAyBZ,OAAzB,EAAkC2B,KAAlC,EAAyC,IAAzC,CAAV;QACD,CARM,MAQA,IACL,CAACA,KAAK,CAACgC,KAAN,KAAgBF,YAAK,CAACK,MAAtB,IAAgCnC,KAAK,CAACgC,KAAN,KAAgBF,YAAK,CAACM,SAAvD,KACApC,KAAK,CAACgC,KAAN,KAAgBhC,KAAK,CAACe,QAFjB,EAGL;UACA,IAAIf,KAAK,CAACe,QAAN,KAAmBe,YAAK,CAACG,MAA7B,EAAqC;YACnClC,UAAU,CAACzB,sBAAa,CAACS,GAAf,EAAoBV,OAApB,EAA6B2B,KAA7B,EAAoC,KAApC,CAAV;UACD;UACDD,UAAU,CAACzB,sBAAa,CAACW,QAAf,EAAyBZ,OAAzB,EAAkC2B,KAAlC,EAAyC,KAAzC,CAAV;QACD;MACF,CA9BD,MA8BO,IAAIgB,YAAY,CAAChB,KAAD,CAAhB,EAAyB;QAC9B,IAAI,CAACwB,gBAAgB,CAACI,CAAD,CAArB,EAA0B;UACxBJ,gBAAgB,CAACI,CAAD,CAAhB,GAAsBS,wCAAmB,CAACC,MAApB,CAA2BtC,KAAK,CAAC6B,UAAjC,CAAtB;QACD;QAED,IAAI7B,KAAK,CAACJ,SAAN,KAAoBC,8BAAc,CAACkC,YAAvC,EAAqD;UACnDhC,UAAU,CACRJ,4BAA4B,CAACK,KAAK,CAACJ,SAAP,CADpB,EAERvB,OAFQ,EAGR2B,KAHQ,EAIRwB,gBAAgB,CAACI,CAAD,CAJR,CAAV;QAMD;MACF,CAbM,MAaA;QACL7B,UAAU,CAACzB,sBAAa,CAACK,MAAf,EAAuBN,OAAvB,EAAgC2B,KAAhC,CAAV;QAEA,IAAI3B,OAAO,CAACS,QAAR,IAAoBT,OAAO,CAACkE,qBAAhC,EAAuD;UAAA,IAAAC,qBAAA;UACrDzC,UAAU,CACRzB,sBAAa,CAACO,MADN,EAERR,OAFQ,GAAAmE,qBAAA,GAGRnE,OAAO,CAACkE,qBAHA,cAAAC,qBAAA,uBAGRA,qBAAA,CAAAC,IAAA,CAAApE,OAAO,EACL2B,KADK,EAELuB,eAAe,CAACI,KAAhB,CAAsBtD,OAAO,CAACwD,UAA9B,CAFK,CAHC,CAAV;UASAN,eAAe,CAACI,KAAhB,CAAsBtD,OAAO,CAACwD,UAA9B,IAA4C7B,KAA5C;QACD;MACF;IACF;EACF,CA7ED;EAgFA,IAAMA,KAAK,GAAGoB,6BAAU,CAACsB,QAAX,CACZjB,QADY,EAEZ,CAAC,6BAAD,EAAgC,uBAAhC,CAFY,EAGZN,YAHY,CAAd;EAMAD,eAAe,CAACyB,oBAAhB,GAAuC3C,KAAvC;EACAkB,eAAe,CAAC0B,gBAAhB,GAAmCvB,uBAAnC;AACD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}