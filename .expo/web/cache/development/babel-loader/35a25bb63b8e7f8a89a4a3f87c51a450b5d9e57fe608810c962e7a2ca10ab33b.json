{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateHandlers = updateHandlers;\nvar _handlersRegistry = require(\"../../handlersRegistry\");\nvar _RNGestureHandlerModule = _interopRequireDefault(require(\"../../../RNGestureHandlerModule\"));\nvar _utils = require(\"../../utils\");\nvar _ghQueueMicrotask = require(\"../../../ghQueueMicrotask\");\nvar _utils2 = require(\"./utils\");\nfunction updateHandlers(preparedGesture, gestureConfig, newGestures) {\n  gestureConfig.prepare();\n  for (var i = 0; i < newGestures.length; i++) {\n    var handler = preparedGesture.attachedGestures[i];\n    (0, _utils2.checkGestureCallbacksForWorklets)(handler);\n    if (newGestures[i].handlerTag !== handler.handlerTag) {\n      newGestures[i].handlerTag = handler.handlerTag;\n      newGestures[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n  (0, _ghQueueMicrotask.ghQueueMicrotask)(function () {\n    if (!preparedGesture.isMounted) {\n      return;\n    }\n    var shouldUpdateSharedValueIfUsed = preparedGesture.attachedGestures.length !== newGestures.length;\n    for (var _i = 0; _i < newGestures.length; _i++) {\n      var _handler = preparedGesture.attachedGestures[_i];\n      if (_handler.handlers.gestureId !== newGestures[_i].handlers.gestureId && (newGestures[_i].shouldUseReanimated || _handler.shouldUseReanimated)) {\n        shouldUpdateSharedValueIfUsed = true;\n      }\n      _handler.config = newGestures[_i].config;\n      _handler.handlers = newGestures[_i].handlers;\n      _RNGestureHandlerModule.default.updateGestureHandler(_handler.handlerTag, (0, _utils.filterConfig)(_handler.config, _utils2.ALLOWED_PROPS, (0, _utils2.extractGestureRelations)(_handler)));\n      (0, _handlersRegistry.registerHandler)(_handler.handlerTag, _handler, _handler.config.testId);\n    }\n    if (preparedGesture.animatedHandlers && shouldUpdateSharedValueIfUsed) {\n      var newHandlersValue = preparedGesture.attachedGestures.filter(function (g) {\n        return g.shouldUseReanimated;\n      }).map(function (g) {\n        return g.handlers;\n      });\n      preparedGesture.animatedHandlers.value = newHandlersValue;\n    }\n    (0, _utils.scheduleFlushOperations)();\n  });\n}","map":{"version":3,"names":["_handlersRegistry","require","_RNGestureHandlerModule","_interopRequireDefault","_utils","_ghQueueMicrotask","_utils2","updateHandlers","preparedGesture","gestureConfig","newGestures","prepare","i","length","handler","attachedGestures","checkGestureCallbacksForWorklets","handlerTag","handlers","ghQueueMicrotask","isMounted","shouldUpdateSharedValueIfUsed","gestureId","shouldUseReanimated","config","RNGestureHandlerModule","updateGestureHandler","filterConfig","ALLOWED_PROPS","extractGestureRelations","registerHandler","testId","animatedHandlers","newHandlersValue","filter","g","map","value","scheduleFlushOperations"],"sources":["/Users/primopan/WebstormProjects/AsdLanguauge/AsdLanguage/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector/updateHandlers.ts"],"sourcesContent":["import { GestureType, HandlerCallbacks } from '../gesture';\nimport { registerHandler } from '../../handlersRegistry';\nimport RNGestureHandlerModule from '../../../RNGestureHandlerModule';\nimport { filterConfig, scheduleFlushOperations } from '../../utils';\nimport { ComposedGesture } from '../gestureComposition';\nimport { ghQueueMicrotask } from '../../../ghQueueMicrotask';\nimport { AttachedGestureState } from './types';\nimport {\n  extractGestureRelations,\n  checkGestureCallbacksForWorklets,\n  ALLOWED_PROPS,\n} from './utils';\n\nexport function updateHandlers(\n  preparedGesture: AttachedGestureState,\n  gestureConfig: ComposedGesture | GestureType,\n  newGestures: GestureType[]\n) {\n  gestureConfig.prepare();\n\n  for (let i = 0; i < newGestures.length; i++) {\n    const handler = preparedGesture.attachedGestures[i];\n    checkGestureCallbacksForWorklets(handler);\n\n    // Only update handlerTag when it's actually different, it may be the same\n    // if gesture config object is wrapped with useMemo\n    if (newGestures[i].handlerTag !== handler.handlerTag) {\n      newGestures[i].handlerTag = handler.handlerTag;\n      newGestures[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n\n  // Use queueMicrotask to extract handlerTags, because when it's ran, all refs should be updated\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\n  // in case of external relations)\n  ghQueueMicrotask(() => {\n    if (!preparedGesture.isMounted) {\n      return;\n    }\n\n    // If amount of gesture configs changes, we need to update the callbacks in shared value\n    let shouldUpdateSharedValueIfUsed =\n      preparedGesture.attachedGestures.length !== newGestures.length;\n\n    for (let i = 0; i < newGestures.length; i++) {\n      const handler = preparedGesture.attachedGestures[i];\n\n      // If the gestureId is different (gesture isn't wrapped with useMemo or its dependencies changed),\n      // we need to update the shared value, assuming the gesture runs on UI thread or the thread changed\n      if (\n        handler.handlers.gestureId !== newGestures[i].handlers.gestureId &&\n        (newGestures[i].shouldUseReanimated || handler.shouldUseReanimated)\n      ) {\n        shouldUpdateSharedValueIfUsed = true;\n      }\n\n      handler.config = newGestures[i].config;\n      handler.handlers = newGestures[i].handlers;\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(\n          handler.config,\n          ALLOWED_PROPS,\n          extractGestureRelations(handler)\n        )\n      );\n\n      registerHandler(handler.handlerTag, handler, handler.config.testId);\n    }\n\n    if (preparedGesture.animatedHandlers && shouldUpdateSharedValueIfUsed) {\n      const newHandlersValue = preparedGesture.attachedGestures\n        .filter((g) => g.shouldUseReanimated) // Ignore gestures that shouldn't run on UI\n        .map((g) => g.handlers) as unknown as HandlerCallbacks<\n        Record<string, unknown>\n      >[];\n\n      preparedGesture.animatedHandlers.value = newHandlersValue;\n    }\n\n    scheduleFlushOperations();\n  });\n}\n"],"mappings":";;;;;AACA,IAAAA,iBAAA,GAAAC,OAAA;AACA,IAAAC,uBAAA,GAAAC,sBAAA,CAAAF,OAAA;AACA,IAAAG,MAAA,GAAAH,OAAA;AAEA,IAAAI,iBAAA,GAAAJ,OAAA;AAEA,IAAAK,OAAA,GAAAL,OAAA;AAMO,SAASM,cAATA,CACLC,eADK,EAELC,aAFK,EAGLC,WAHK,EAIL;EACAD,aAAa,CAACE,OAAd;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,WAAW,CAACG,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;IAC3C,IAAME,OAAO,GAAGN,eAAe,CAACO,gBAAhB,CAAiCH,CAAjC,CAAhB;IACA,IAAAI,wCAAgC,EAACF,OAAD,CAAhC;IAIA,IAAIJ,WAAW,CAACE,CAAD,CAAX,CAAeK,UAAf,KAA8BH,OAAO,CAACG,UAA1C,EAAsD;MACpDP,WAAW,CAACE,CAAD,CAAX,CAAeK,UAAf,GAA4BH,OAAO,CAACG,UAApC;MACAP,WAAW,CAACE,CAAD,CAAX,CAAeM,QAAf,CAAwBD,UAAxB,GAAqCH,OAAO,CAACG,UAA7C;IACD;EACF;EAKD,IAAAE,kCAAgB,EAAC,YAAM;IACrB,IAAI,CAACX,eAAe,CAACY,SAArB,EAAgC;MAC9B;IACD;IAGD,IAAIC,6BAA6B,GAC/Bb,eAAe,CAACO,gBAAhB,CAAiCF,MAAjC,KAA4CH,WAAW,CAACG,MAD1D;IAGA,KAAK,IAAID,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGF,WAAW,CAACG,MAAhC,EAAwCD,EAAC,EAAzC,EAA6C;MAC3C,IAAME,QAAO,GAAGN,eAAe,CAACO,gBAAhB,CAAiCH,EAAjC,CAAhB;MAIA,IACEE,QAAO,CAACI,QAAR,CAAiBI,SAAjB,KAA+BZ,WAAW,CAACE,EAAD,CAAX,CAAeM,QAAf,CAAwBI,SAAvD,KACCZ,WAAW,CAACE,EAAD,CAAX,CAAeW,mBAAf,IAAsCT,QAAO,CAACS,mBAD/C,CADF,EAGE;QACAF,6BAA6B,GAAG,IAAhC;MACD;MAEDP,QAAO,CAACU,MAAR,GAAiBd,WAAW,CAACE,EAAD,CAAX,CAAeY,MAAhC;MACAV,QAAO,CAACI,QAAR,GAAmBR,WAAW,CAACE,EAAD,CAAX,CAAeM,QAAlC;MAEAO,+BAAsB,CAACC,oBAAvB,CACEZ,QAAO,CAACG,UADV,EAEE,IAAAU,mBAAY,EACVb,QAAO,CAACU,MADE,EAEVI,qBAFU,EAGV,IAAAC,+BAAuB,EAACf,QAAD,CAHb,CAFd;MASA,IAAAgB,iCAAe,EAAChB,QAAO,CAACG,UAAT,EAAqBH,QAArB,EAA8BA,QAAO,CAACU,MAAR,CAAeO,MAA7C,CAAf;IACD;IAED,IAAIvB,eAAe,CAACwB,gBAAhB,IAAoCX,6BAAxC,EAAuE;MACrE,IAAMY,gBAAgB,GAAGzB,eAAe,CAACO,gBAAhB,CACtBmB,MADsB,CACd,UAAAC,CAAD;QAAA,OAAOA,CAAC,CAACZ,mBADM;MAAA,GAEtBa,GAFsB,CAEjB,UAAAD,CAAD;QAAA,OAAOA,CAAC,CAACjB,QAFS;MAAA,EAAzB;MAMAV,eAAe,CAACwB,gBAAhB,CAAiCK,KAAjC,GAAyCJ,gBAAzC;IACD;IAED,IAAAK,8BAAuB;EACxB,CA/Ce,CAAhB;AAgDD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}